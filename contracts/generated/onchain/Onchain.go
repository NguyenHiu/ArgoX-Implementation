// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package onchain

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// OnchainBatch is an auto generated low-level Go binding around an user-defined struct.
type OnchainBatch struct {
	BatchID   [16]byte
	Price     *big.Int
	Amount    *big.Int
	Side      bool
	Owner     common.Address
	Signature []byte
	Time      *big.Int
}

// OnchainOrder is an auto generated low-level Go binding around an user-defined struct.
type OnchainOrder struct {
	OrderID   [16]byte
	Price     *big.Int
	Amount    *big.Int
	Side      bool
	Signature []byte
	Owner     common.Address
}

// OnchainMetaData contains all meta data concerning the Onchain contract.
var OnchainMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"StringsInsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"AcceptBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"FullfilMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"LogBytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"LogBytes16\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"LogBytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumECDSA.RecoverError\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"LogRecoverError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"PartialMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PunishMatcher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"ReceivedBatchDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RemoveBatchOutOfDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RevertBatch\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GetAskOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"structOnchain.Batch[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetBidOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"structOnchain.Batch[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"deleteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"isMatcher\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"isPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"reportMissingDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sign\",\"type\":\"bytes\"}],\"name\":\"sendBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"orderID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"structOnchain.Order[]\",\"name\":\"_ords\",\"type\":\"tuple[]\"}],\"name\":\"submitOrderDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"uintToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561000f575f80fd5b50670de0b6b3a7640000600281905550600560038190555061492c806100345f395ff3fe6080604052600436106100dc575f3560e01c806355a339681161007e57806382736cd71161005857806382736cd7146102a65780638545dca2146102ce578063b29e6299146102f8578063e939567914610320576100dc565b806355a33968146102185780635e57966d1461024257806378b32cf51461027e576100dc565b806332a58e79116100ba57806332a58e791461016c57806336ee6749146101965780634420e486146101d25780634dcbd09b146101ee576100dc565b8063123cab3c146100e057806319f5e9fe146101085780633005d34c14610144575b5f80fd5b3480156100eb575f80fd5b50610106600480360381019061010191906138d9565b61035c565b005b348015610113575f80fd5b5061012e60048036038101906101299190613933565b610b4e565b60405161013b919061396d565b60405180910390f35b34801561014f575f80fd5b5061016a60048036038101906101659190613986565b610be6565b005b348015610177575f80fd5b50610180610c90565b60405161018d9190613a3a565b60405180910390f35b3480156101a1575f80fd5b506101bc60048036038101906101b79190613a53565b610c99565b6040516101c9919061396d565b60405180910390f35b6101ec60048036038101906101e79190613a53565b610ce2565b005b3480156101f9575f80fd5b50610202610d6e565b60405161020f9190613a3a565b60405180910390f35b348015610223575f80fd5b5061022c610d77565b6040516102399190613c88565b60405180910390f35b34801561024d575f80fd5b5061026860048036038101906102639190613a53565b610f2b565b6040516102759190613cfa565b60405180910390f35b348015610289575f80fd5b506102a4600480360381019061029f9190613933565b610f55565b005b3480156102b1575f80fd5b506102cc60048036038101906102c79190613d1a565b6112a8565b005b3480156102d9575f80fd5b506102e26114e8565b6040516102ef9190613c88565b60405180910390f35b348015610303575f80fd5b5061031e60048036038101906103199190613933565b61169d565b005b34801561032b575f80fd5b5061034660048036038101906103419190613d58565b611954565b6040516103539190613cfa565b60405180910390f35b815f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154036103d9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103d090613dcd565b60405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146104a2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161049990613e35565b60405180910390fd5b5f60605f5b85518160ff16101561076e575f868260ff16815181106104ca576104c9613e53565b5b60200260200101515f0151878360ff16815181106104eb576104ea613e53565b5b602002602001015160200151888460ff168151811061050d5761050c613e53565b5b602002602001015160400151898560ff168151811061052f5761052e613e53565b5b6020026020010151606001518a8660ff168151811061055157610550613e53565b5b602002602001015160a00151604051602001610571959493929190613f4a565b60405160208183030381529060405290505f81805190602001209050878360ff16815181106105a3576105a2613e53565b5b602002602001015160a0015173ffffffffffffffffffffffffffffffffffffffff166105f0828a8660ff16815181106105df576105de613e53565b5b602002602001015160800151611966565b73ffffffffffffffffffffffffffffffffffffffff161461064c577fbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a92987854478960405161063a9190613fb7565b60405180910390a15050505050610b48565b878360ff168151811061066257610661613e53565b5b602002602001015160400151856106799190613ffd565b94505f888460ff168151811061069257610691613e53565b5b6020026020010151608001519050601b816040815181106106b6576106b5613e53565b5b602001015160f81c60f81b60f81c6106ce919061403c565b60f81b816040815181106106e5576106e4613e53565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053508483826040516020016107279291906140aa565b6040516020818303038152906040526040516020016107479291906140aa565b60405160208183030381529060405294505050508080610766906140cd565b9150506104a7565b5060055f876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002015482146107ee577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748866040516107df9190613fb7565b60405180910390a15050610b48565b5f610a008760055f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206001015460055f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002015460055f8c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff168a518760055f8f6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604051602001610924979695949392919061410c565b6040516020818303038152906040528051906020012060055f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600401805461097f906141b5565b80601f01602080910402602001604051908101604052809291908181526020018280546109ab906141b5565b80156109f65780601f106109cd576101008083540402835291602001916109f6565b820191905f5260205f20905b8154815290600101906020018083116109d957829003601f168201915b5050505050611966565b905060055f886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610ace577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad74887604051610abe9190613fb7565b60405180910390a1505050610b48565b5f60055f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055507f9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e87604051610b3c9190613fb7565b60405180910390a15050505b50505050565b5f8060055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015414158015610bdf57504260035460055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154610bdd9190613ffd565b105b9050919050565b7f48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d86604051610c159190613fb7565b60405180910390a15f6040518060e00160405280886fffffffffffffffffffffffffffffffff1916815260200187815260200186815260200185151581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018381526020015f8152509050610c8781611990565b50505050505050565b5f600254905090565b5f8060045f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205414159050919050565b600254341015610d27576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d1e9061422f565b60405180910390fd5b60025460045f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208190555050565b5f600354905090565b60605f805480602002602001604051908101604052809291908181526020015f905b82821015610f22578382905f5260205f2090600602016040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600482018054610e89906141b5565b80601f0160208091040260200160405190810160405280929190818152602001828054610eb5906141b5565b8015610f005780601f10610ed757610100808354040283529160200191610f00565b820191905f5260205f20905b815481529060010190602001808311610ee357829003601f168201915b5050505050815260200160058201548152505081526020019060010190610d99565b50505050905090565b6060610f4e8273ffffffffffffffffffffffffffffffffffffffff1660146119c2565b9050919050565b805f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015403610fd2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fc990613dcd565b60405180910390fd5b4260035460055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015461101b9190613ffd565b1061105b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161105290614297565b60405180910390fd5b5f60045f60055f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055505f60055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055505f60065f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b905060065f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154906fffffffffffffffffffffffffffffffff02191690556111db81611c00565b7fef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b6602208360405161120a9190613fb7565b60405180910390a17f5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba2360055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660405161129b91906142c4565b60405180910390a1505050565b813373ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611371576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161136890613e35565b60405180910390fd5b825f73ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361143a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161143190614327565b60405180910390fd5b60055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff1615611496576114915f8585611e8a565b6114a3565b6114a260018585611e8a565b5b8260055f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002018190555050505050565b60606001805480602002602001604051908101604052809291908181526020015f905b82821015611694578382905f5260205f2090600602016040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016004820180546115fb906141b5565b80601f0160208091040260200160405190810160405280929190818152602001828054611627906141b5565b80156116725780601f1061164957610100808354040283529160200191611672565b820191905f5260205f20905b81548152906001019060200180831161165557829003601f168201915b505050505081526020016005820154815250508152602001906001019061150b565b50505050905090565b803373ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611766576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161175d90613e35565b60405180910390fd5b815f73ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361182f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161182690614327565b60405180910390fd5b60055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff161561188a576118855f84611f31565b611896565b611895600184611f31565b5b60055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f8082015f6101000a8154906fffffffffffffffffffffffffffffffff0219169055600182015f9055600282015f9055600382015f6101000a81549060ff02191690556003820160016101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055600482015f611946919061347a565b600582015f90555050505050565b606061195f826121c2565b9050919050565b5f805f80611974868661228c565b92509250925061198482826122e1565b82935050505092915050565b8060600151156119aa576119a45f82612443565b506119b7565b6119b5600182612443565b505b6119bf6129fd565b50565b60605f8390505f60028460026119d89190614345565b6119e29190613ffd565b67ffffffffffffffff8111156119fb576119fa61354c565b5b6040519080825280601f01601f191660200182016040528015611a2d5781602001600182028036833780820191505090505b5090507f3000000000000000000000000000000000000000000000000000000000000000815f81518110611a6457611a63613e53565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110611ac757611ac6613e53565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505f6001856002611b059190614345565b611b0f9190613ffd565b90505b6001811115611bae577f3031323334353637383961626364656600000000000000000000000000000000600f841660108110611b5157611b50613e53565b5b1a60f81b828281518110611b6857611b67613e53565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600483901c925080611ba790614386565b9050611b12565b505f8214611bf55784846040517fe22e27eb000000000000000000000000000000000000000000000000000000008152600401611bec9291906143ad565b60405180910390fd5b809250505092915050565b5f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154148015611ca257505f60801b60065f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff191614155b15611e87577ff335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd681604051611cd69190613fb7565b60405180910390a15f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600482018054611df0906141b5565b80601f0160208091040260200160405190810160405280929190818152602001828054611e1c906141b5565b8015611e675780601f10611e3e57610100808354040283529160200191611e67565b820191905f5260205f20905b815481529060010190602001808311611e4a57829003601f168201915b505050505081526020016005820154815250509050611e8581611990565b505b50565b5f5b8380549050811015611f2b57826fffffffffffffffffffffffffffffffff1916848281548110611ebf57611ebe613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff191603611f1e5781848281548110611f0657611f05613e53565b5b905f5260205f20906006020160020181905550611f2b565b8080600101915050611e8c565b50505050565b5f805b60018480549050611f4591906143d4565b8110156121155781158015611fac5750826fffffffffffffffffffffffffffffffff1916848281548110611f7c57611f7b613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff1916145b15611fb657600191505b81156121085783600182611fca9190613ffd565b81548110611fdb57611fda613e53565b5b905f5260205f209060060201848281548110611ffa57611ff9613e53565b5b905f5260205f2090600602015f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600482018160040190816120f991906145b9565b50600582015481600501559050505b8080600101915050611f34565b50828054806121275761212661469e565b5b600190038181905f5260205f2090600602015f8082015f6101000a8154906fffffffffffffffffffffffffffffffff0219169055600182015f9055600282015f9055600382015f6101000a81549060ff02191690556003820160016101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055600482015f6121b2919061347a565b600582015f905550509055505050565b60605f60016121d084613242565b0190505f8167ffffffffffffffff8111156121ee576121ed61354c565b5b6040519080825280601f01601f1916602001820160405280156122205781602001600182028036833780820191505090505b5090505f82602001820190505b600115612281578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612276576122756146cb565b5b0494505f850361222d575b819350505050919050565b5f805f60418451036122cc575f805f602087015192506040870151915060608701515f1a90506122be88828585613393565b9550955095505050506122da565b5f600285515f1b9250925092505b9250925092565b5f60038111156122f4576122f36146f8565b5b826003811115612307576123066146f8565b5b031561243f5760016003811115612321576123206146f8565b5b826003811115612334576123336146f8565b5b0361236b576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561237f5761237e6146f8565b5b826003811115612392576123916146f8565b5b036123d657805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016123cd9190613a3a565b60405180910390fd5b6003808111156123e9576123e86146f8565b5b8260038111156123fc576123fb6146f8565b5b0361243e57806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401612435919061473d565b60405180910390fd5b5b5050565b5f807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905082606001511561247757600190505b5f848054905014806124d5575080846001868054905061249791906143d4565b815481106124a8576124a7613e53565b5b905f5260205f209060060201600101546124c2919061475f565b8184602001516124d2919061475f565b13155b156125d0578383908060018154018082558091505060019003905f5260205f2090600602015f909190919091505f820151815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555060208201518160010155604082015181600201556060820151816003015f6101000a81548160ff02191690831515021790555060808201518160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060a08201518160040190816125be91906147d5565b5060c0820151816005015550506129f2565b5f5b84805490508110156129f057818582815481106125f2576125f1613e53565b5b905f5260205f2090600602016001015461260c919061475f565b82856020015161261c919061475f565b13156129e35784856001878054905061263591906143d4565b8154811061264657612645613e53565b5b905f5260205f209060060201908060018154018082558091505060019003905f5260205f2090600602015f909190919091505f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506004820181600401908161276b91906145b9565b506005820154816005015550505f6002868054905061278a91906143d4565b90505b818111156128f357856001826127a391906143d4565b815481106127b4576127b3613e53565b5b905f5260205f2090600602018682815481106127d3576127d2613e53565b5b905f5260205f2090600602015f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600482018160040190816128d291906145b9565b506005820154816005015590505080806128eb90614386565b91505061278d565b508385828154811061290857612907613e53565b5b905f5260205f2090600602015f820151815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555060208201518160010155604082015181600201556060820151816003015f6101000a81548160ff02191690831515021790555060808201518160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060a08201518160040190816129d091906147d5565b5060c082015181600501559050506129f0565b80806001019150506125d2565b505b600191505092915050565b5b5f808054905014158015612a1757505f60018054905014155b8015612a68575060015f81548110612a3257612a31613e53565b5b905f5260205f209060060201600101545f8081548110612a5557612a54613e53565b5b905f5260205f2090600602016001015410155b156132405760015f81548110612a8157612a80613e53565b5b905f5260205f209060060201600201545f8081548110612aa457612aa3613e53565b5b905f5260205f209060060201600201541115612b525760015f81548110612ace57612acd613e53565b5b905f5260205f209060060201600201545f8081548110612af157612af0613e53565b5b905f5260205f2090600602016002015f828254612b0e91906143d4565b92505081905550612b4d6001805f81548110612b2d57612b2c613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b611f31565b61323b565b60015f81548110612b6657612b65613e53565b5b905f5260205f209060060201600201545f8081548110612b8957612b88613e53565b5b905f5260205f209060060201600201541015612c36575f8081548110612bb257612bb1613e53565b5b905f5260205f2090600602016002015460015f81548110612bd657612bd5613e53565b5b905f5260205f2090600602016002015f828254612bf391906143d4565b92505081905550612c315f805f81548110612c1157612c10613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b611f31565b61323a565b425f8081548110612c4a57612c49613e53565b5b905f5260205f209060060201600501819055505f8081548110612c7057612c6f613e53565b5b905f5260205f20906006020160055f805f81548110612c9257612c91613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048201816004019081612dd391906145b9565b50600582015481600501559050504260015f81548110612df657612df5613e53565b5b905f5260205f2090600602016005018190555060015f81548110612e1d57612e1c613e53565b5b905f5260205f20906006020160055f60015f81548110612e4057612e3f613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048201816004019081612f8191906145b9565b506005820154816005015590505060015f81548110612fa357612fa2613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b60065f805f81548110612fd457612fd3613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055505f808154811061305b5761305a613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b60065f60015f8154811061308d5761308c613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055507f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae9655f808154811061313557613134613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b60405161315d9190613fb7565b60405180910390a17f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae96560015f8154811061319a57613199613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b6040516131c29190613fb7565b60405180910390a16132026001805f815481106131e2576131e1613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b611f31565b6132395f805f8154811061321957613218613e53565b5b905f5260205f2090600602015f015f9054906101000a900460801b611f31565b5b5b6129fe565b565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061329e577a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008381613294576132936146cb565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106132db576d04ee2d6d415b85acef810000000083816132d1576132d06146cb565b5b0492506020810190505b662386f26fc10000831061330a57662386f26fc100008381613300576132ff6146cb565b5b0492506010810190505b6305f5e1008310613333576305f5e1008381613329576133286146cb565b5b0492506008810190505b612710831061335857612710838161334e5761334d6146cb565b5b0492506004810190505b6064831061337b5760648381613371576133706146cb565b5b0492506002810190505b600a831061338a576001810190505b80915050919050565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c11156133cf575f600385925092509250613470565b5f6001888888886040515f81526020016040526040516133f294939291906148b3565b6020604051602081039080840390855afa158015613412573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603613463575f60015f801b93509350935050613470565b805f805f1b935093509350505b9450945094915050565b508054613486906141b5565b5f825580601f1061349757506134b4565b601f0160209004905f5260205f20908101906134b391906134b7565b5b50565b5b808211156134ce575f815f9055506001016134b8565b5090565b5f604051905090565b5f80fd5b5f80fd5b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b613517816134e3565b8114613521575f80fd5b50565b5f813590506135328161350e565b92915050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6135828261353c565b810181811067ffffffffffffffff821117156135a1576135a061354c565b5b80604052505050565b5f6135b36134d2565b90506135bf8282613579565b919050565b5f67ffffffffffffffff8211156135de576135dd61354c565b5b602082029050602081019050919050565b5f80fd5b5f80fd5b5f80fd5b5f819050919050565b61360d816135fb565b8114613617575f80fd5b50565b5f8135905061362881613604565b92915050565b5f8115159050919050565b6136428161362e565b811461364c575f80fd5b50565b5f8135905061365d81613639565b92915050565b5f80fd5b5f67ffffffffffffffff8211156136815761368061354c565b5b61368a8261353c565b9050602081019050919050565b828183375f83830152505050565b5f6136b76136b284613667565b6135aa565b9050828152602081018484840111156136d3576136d2613663565b5b6136de848285613697565b509392505050565b5f82601f8301126136fa576136f9613538565b5b813561370a8482602086016136a5565b91505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61373c82613713565b9050919050565b61374c81613732565b8114613756575f80fd5b50565b5f8135905061376781613743565b92915050565b5f60c08284031215613782576137816135f3565b5b61378c60c06135aa565b90505f61379b84828501613524565b5f8301525060206137ae8482850161361a565b60208301525060406137c28482850161361a565b60408301525060606137d68482850161364f565b606083015250608082013567ffffffffffffffff8111156137fa576137f96135f7565b5b613806848285016136e6565b60808301525060a061381a84828501613759565b60a08301525092915050565b5f613838613833846135c4565b6135aa565b9050808382526020820190506020840283018581111561385b5761385a6135ef565b5b835b818110156138a257803567ffffffffffffffff8111156138805761387f613538565b5b80860161388d898261376d565b8552602085019450505060208101905061385d565b5050509392505050565b5f82601f8301126138c0576138bf613538565b5b81356138d0848260208601613826565b91505092915050565b5f80604083850312156138ef576138ee6134db565b5b5f6138fc85828601613524565b925050602083013567ffffffffffffffff81111561391d5761391c6134df565b5b613929858286016138ac565b9150509250929050565b5f60208284031215613948576139476134db565b5b5f61395584828501613524565b91505092915050565b6139678161362e565b82525050565b5f6020820190506139805f83018461395e565b92915050565b5f805f805f8060c087890312156139a05761399f6134db565b5b5f6139ad89828a01613524565b96505060206139be89828a0161361a565b95505060406139cf89828a0161361a565b94505060606139e089828a0161364f565b93505060806139f189828a01613759565b92505060a087013567ffffffffffffffff811115613a1257613a116134df565b5b613a1e89828a016136e6565b9150509295509295509295565b613a34816135fb565b82525050565b5f602082019050613a4d5f830184613a2b565b92915050565b5f60208284031215613a6857613a676134db565b5b5f613a7584828501613759565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b613ab0816134e3565b82525050565b613abf816135fb565b82525050565b613ace8161362e565b82525050565b613add81613732565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015613b1a578082015181840152602081019050613aff565b5f8484015250505050565b5f613b2f82613ae3565b613b398185613aed565b9350613b49818560208601613afd565b613b528161353c565b840191505092915050565b5f60e083015f830151613b725f860182613aa7565b506020830151613b856020860182613ab6565b506040830151613b986040860182613ab6565b506060830151613bab6060860182613ac5565b506080830151613bbe6080860182613ad4565b5060a083015184820360a0860152613bd68282613b25565b91505060c0830151613beb60c0860182613ab6565b508091505092915050565b5f613c018383613b5d565b905092915050565b5f602082019050919050565b5f613c1f82613a7e565b613c298185613a88565b935083602082028501613c3b85613a98565b805f5b85811015613c765784840389528151613c578582613bf6565b9450613c6283613c09565b925060208a01995050600181019050613c3e565b50829750879550505050505092915050565b5f6020820190508181035f830152613ca08184613c15565b905092915050565b5f81519050919050565b5f82825260208201905092915050565b5f613ccc82613ca8565b613cd68185613cb2565b9350613ce6818560208601613afd565b613cef8161353c565b840191505092915050565b5f6020820190508181035f830152613d128184613cc2565b905092915050565b5f8060408385031215613d3057613d2f6134db565b5b5f613d3d85828601613524565b9250506020613d4e8582860161361a565b9150509250929050565b5f60208284031215613d6d57613d6c6134db565b5b5f613d7a8482850161361a565b91505092915050565b7f746865206261746368206973206e6f742070656e64696e6700000000000000005f82015250565b5f613db7601883613cb2565b9150613dc282613d83565b602082019050919050565b5f6020820190508181035f830152613de481613dab565b9050919050565b7f726571756972652062617463682773206f0000000000000000000000000000005f82015250565b5f613e1f601183613cb2565b9150613e2a82613deb565b602082019050919050565b5f6020820190508181035f830152613e4c81613e13565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f819050919050565b613e9a613e95826134e3565b613e80565b82525050565b5f819050919050565b613eba613eb5826135fb565b613ea0565b82525050565b5f8160f81b9050919050565b5f613ed682613ec0565b9050919050565b5f613ee782613ecc565b9050919050565b613eff613efa8261362e565b613edd565b82525050565b5f8160601b9050919050565b5f613f1b82613f05565b9050919050565b5f613f2c82613f11565b9050919050565b613f44613f3f82613732565b613f22565b82525050565b5f613f558288613e89565b601082019150613f658287613ea9565b602082019150613f758286613ea9565b602082019150613f858285613eee565b600182019150613f958284613f33565b6014820191508190509695505050505050565b613fb1816134e3565b82525050565b5f602082019050613fca5f830184613fa8565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f614007826135fb565b9150614012836135fb565b925082820190508082111561402a57614029613fd0565b5b92915050565b5f60ff82169050919050565b5f61404682614030565b915061405183614030565b9250828203905060ff81111561406a57614069613fd0565b5b92915050565b5f81905092915050565b5f61408482613ae3565b61408e8185614070565b935061409e818560208601613afd565b80840191505092915050565b5f6140b5828561407a565b91506140c1828461407a565b91508190509392505050565b5f6140d782614030565b915060ff82036140ea576140e9613fd0565b5b600182019050919050565b61410661410182614030565b613ecc565b82525050565b5f614117828a613e89565b6010820191506141278289613ea9565b6020820191506141378288613ea9565b6020820191506141478287613eee565b60018201915061415782866140f5565b600182019150614167828561407a565b91506141738284613f33565b60148201915081905098975050505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806141cc57607f821691505b6020821081036141df576141de614188565b5b50919050565b7f726567697374657220666565206973206e6f7420656e6f7567680000000000005f82015250565b5f614219601a83613cb2565b9150614224826141e5565b602082019050919050565b5f6020820190508181035f8301526142468161420d565b9050919050565b7f746865206261746368206973206e6f74206f75742d6f662d64617465000000005f82015250565b5f614281601c83613cb2565b915061428c8261424d565b602082019050919050565b5f6020820190508181035f8301526142ae81614275565b9050919050565b6142be81613732565b82525050565b5f6020820190506142d75f8301846142b5565b92915050565b7f74686520626174636820646f6573206e6f7420657869737400000000000000005f82015250565b5f614311601883613cb2565b915061431c826142dd565b602082019050919050565b5f6020820190508181035f83015261433e81614305565b9050919050565b5f61434f826135fb565b915061435a836135fb565b9250828202614368816135fb565b9150828204841483151761437f5761437e613fd0565b5b5092915050565b5f614390826135fb565b91505f82036143a2576143a1613fd0565b5b600182039050919050565b5f6040820190506143c05f830185613a2b565b6143cd6020830184613a2b565b9392505050565b5f6143de826135fb565b91506143e9836135fb565b925082820390508181111561440157614400613fd0565b5b92915050565b5f81549050614415816141b5565b9050919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026144787fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261443d565b614482868361443d565b95508019841693508086168417925050509392505050565b5f819050919050565b5f6144bd6144b86144b3846135fb565b61449a565b6135fb565b9050919050565b5f819050919050565b6144d6836144a3565b6144ea6144e2826144c4565b848454614449565b825550505050565b5f90565b6144fe6144f2565b6145098184846144cd565b505050565b5b8181101561452c576145215f826144f6565b60018101905061450f565b5050565b601f821115614571576145428161441c565b61454b8461442e565b8101602085101561455a578190505b61456e6145668561442e565b83018261450e565b50505b505050565b5f82821c905092915050565b5f6145915f1984600802614576565b1980831691505092915050565b5f6145a98383614582565b9150826002028217905092915050565b8181036145c757505061469c565b6145d082614407565b67ffffffffffffffff8111156145e9576145e861354c565b5b6145f382546141b5565b6145fe828285614530565b5f601f83116001811461462b575f8415614619578287015490505b614623858261459e565b865550614695565b601f1984166146398761441c565b96506146448661441c565b5f5b8281101561466b57848901548255600182019150600185019450602081019050614646565b868310156146885784890154614684601f891682614582565b8355505b6001600288020188555050505b5050505050505b565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f819050919050565b61473781614725565b82525050565b5f6020820190506147505f83018461472e565b92915050565b5f819050919050565b5f61476982614756565b915061477483614756565b925082820261478281614756565b91507f800000000000000000000000000000000000000000000000000000000000000084145f841216156147b9576147b8613fd0565b5b82820584148315176147ce576147cd613fd0565b5b5092915050565b6147de82613ae3565b67ffffffffffffffff8111156147f7576147f661354c565b5b61480182546141b5565b61480c828285614530565b5f60209050601f83116001811461483d575f841561482b578287015190505b614835858261459e565b86555061489c565b601f19841661484b8661441c565b5f5b828110156148725784890151825560018201915060208501945060208101905061484d565b8683101561488f578489015161488b601f891682614582565b8355505b6001600288020188555050505b505050505050565b6148ad81614030565b82525050565b5f6080820190506148c65f83018761472e565b6148d360208301866148a4565b6148e0604083018561472e565b6148ed606083018461472e565b9594505050505056fea2646970667358221220e9d1e775ed43970d05513f0bf8a718b89770cffccf2cc48480c3943b4fab8baa64736f6c63430008180033",
}

// OnchainABI is the input ABI used to generate the binding from.
// Deprecated: Use OnchainMetaData.ABI instead.
var OnchainABI = OnchainMetaData.ABI

// OnchainBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OnchainMetaData.Bin instead.
var OnchainBin = OnchainMetaData.Bin

// DeployOnchain deploys a new Ethereum contract, binding an instance of Onchain to it.
func DeployOnchain(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Onchain, error) {
	parsed, err := OnchainMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OnchainBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Onchain{OnchainCaller: OnchainCaller{contract: contract}, OnchainTransactor: OnchainTransactor{contract: contract}, OnchainFilterer: OnchainFilterer{contract: contract}}, nil
}

// Onchain is an auto generated Go binding around an Ethereum contract.
type Onchain struct {
	OnchainCaller     // Read-only binding to the contract
	OnchainTransactor // Write-only binding to the contract
	OnchainFilterer   // Log filterer for contract events
}

// OnchainCaller is an auto generated read-only Go binding around an Ethereum contract.
type OnchainCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OnchainTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OnchainFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OnchainSession struct {
	Contract     *Onchain          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OnchainCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OnchainCallerSession struct {
	Contract *OnchainCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OnchainTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OnchainTransactorSession struct {
	Contract     *OnchainTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OnchainRaw is an auto generated low-level Go binding around an Ethereum contract.
type OnchainRaw struct {
	Contract *Onchain // Generic contract binding to access the raw methods on
}

// OnchainCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OnchainCallerRaw struct {
	Contract *OnchainCaller // Generic read-only contract binding to access the raw methods on
}

// OnchainTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OnchainTransactorRaw struct {
	Contract *OnchainTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOnchain creates a new instance of Onchain, bound to a specific deployed contract.
func NewOnchain(address common.Address, backend bind.ContractBackend) (*Onchain, error) {
	contract, err := bindOnchain(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Onchain{OnchainCaller: OnchainCaller{contract: contract}, OnchainTransactor: OnchainTransactor{contract: contract}, OnchainFilterer: OnchainFilterer{contract: contract}}, nil
}

// NewOnchainCaller creates a new read-only instance of Onchain, bound to a specific deployed contract.
func NewOnchainCaller(address common.Address, caller bind.ContractCaller) (*OnchainCaller, error) {
	contract, err := bindOnchain(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainCaller{contract: contract}, nil
}

// NewOnchainTransactor creates a new write-only instance of Onchain, bound to a specific deployed contract.
func NewOnchainTransactor(address common.Address, transactor bind.ContractTransactor) (*OnchainTransactor, error) {
	contract, err := bindOnchain(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainTransactor{contract: contract}, nil
}

// NewOnchainFilterer creates a new log filterer instance of Onchain, bound to a specific deployed contract.
func NewOnchainFilterer(address common.Address, filterer bind.ContractFilterer) (*OnchainFilterer, error) {
	contract, err := bindOnchain(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OnchainFilterer{contract: contract}, nil
}

// bindOnchain binds a generic wrapper to an already deployed contract.
func bindOnchain(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OnchainMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Onchain *OnchainRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Onchain.Contract.OnchainCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Onchain *OnchainRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.Contract.OnchainTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Onchain *OnchainRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Onchain.Contract.OnchainTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Onchain *OnchainCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Onchain.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Onchain *OnchainTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Onchain *OnchainTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Onchain.Contract.contract.Transact(opts, method, params...)
}

// GetAskOrders is a free data retrieval call binding the contract method 0x8545dca2.
//
// Solidity: function GetAskOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_Onchain *OnchainCaller) GetAskOrders(opts *bind.CallOpts) ([]OnchainBatch, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "GetAskOrders")

	if err != nil {
		return *new([]OnchainBatch), err
	}

	out0 := *abi.ConvertType(out[0], new([]OnchainBatch)).(*[]OnchainBatch)

	return out0, err

}

// GetAskOrders is a free data retrieval call binding the contract method 0x8545dca2.
//
// Solidity: function GetAskOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_Onchain *OnchainSession) GetAskOrders() ([]OnchainBatch, error) {
	return _Onchain.Contract.GetAskOrders(&_Onchain.CallOpts)
}

// GetAskOrders is a free data retrieval call binding the contract method 0x8545dca2.
//
// Solidity: function GetAskOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_Onchain *OnchainCallerSession) GetAskOrders() ([]OnchainBatch, error) {
	return _Onchain.Contract.GetAskOrders(&_Onchain.CallOpts)
}

// GetBidOrders is a free data retrieval call binding the contract method 0x55a33968.
//
// Solidity: function GetBidOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_Onchain *OnchainCaller) GetBidOrders(opts *bind.CallOpts) ([]OnchainBatch, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "GetBidOrders")

	if err != nil {
		return *new([]OnchainBatch), err
	}

	out0 := *abi.ConvertType(out[0], new([]OnchainBatch)).(*[]OnchainBatch)

	return out0, err

}

// GetBidOrders is a free data retrieval call binding the contract method 0x55a33968.
//
// Solidity: function GetBidOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_Onchain *OnchainSession) GetBidOrders() ([]OnchainBatch, error) {
	return _Onchain.Contract.GetBidOrders(&_Onchain.CallOpts)
}

// GetBidOrders is a free data retrieval call binding the contract method 0x55a33968.
//
// Solidity: function GetBidOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_Onchain *OnchainCallerSession) GetBidOrders() ([]OnchainBatch, error) {
	return _Onchain.Contract.GetBidOrders(&_Onchain.CallOpts)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainCaller) AddressToString(opts *bind.CallOpts, _addr common.Address) (string, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "addressToString", _addr)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainSession) AddressToString(_addr common.Address) (string, error) {
	return _Onchain.Contract.AddressToString(&_Onchain.CallOpts, _addr)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainCallerSession) AddressToString(_addr common.Address) (string, error) {
	return _Onchain.Contract.AddressToString(&_Onchain.CallOpts, _addr)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainCaller) GetRegisterFee(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "getRegisterFee")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainSession) GetRegisterFee() (*big.Int, error) {
	return _Onchain.Contract.GetRegisterFee(&_Onchain.CallOpts)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainCallerSession) GetRegisterFee() (*big.Int, error) {
	return _Onchain.Contract.GetRegisterFee(&_Onchain.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainCaller) GetWaitingTime(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "getWaitingTime")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainSession) GetWaitingTime() (*big.Int, error) {
	return _Onchain.Contract.GetWaitingTime(&_Onchain.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainCallerSession) GetWaitingTime() (*big.Int, error) {
	return _Onchain.Contract.GetWaitingTime(&_Onchain.CallOpts)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainCaller) IsMatcher(opts *bind.CallOpts, _m common.Address) (bool, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "isMatcher", _m)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainSession) IsMatcher(_m common.Address) (bool, error) {
	return _Onchain.Contract.IsMatcher(&_Onchain.CallOpts, _m)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainCallerSession) IsMatcher(_m common.Address) (bool, error) {
	return _Onchain.Contract.IsMatcher(&_Onchain.CallOpts, _m)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainCaller) IsPending(opts *bind.CallOpts, batchID [16]byte) (bool, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "isPending", batchID)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainSession) IsPending(batchID [16]byte) (bool, error) {
	return _Onchain.Contract.IsPending(&_Onchain.CallOpts, batchID)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainCallerSession) IsPending(batchID [16]byte) (bool, error) {
	return _Onchain.Contract.IsPending(&_Onchain.CallOpts, batchID)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainCaller) UintToString(opts *bind.CallOpts, num *big.Int) (string, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "uintToString", num)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainSession) UintToString(num *big.Int) (string, error) {
	return _Onchain.Contract.UintToString(&_Onchain.CallOpts, num)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainCallerSession) UintToString(num *big.Int) (string, error) {
	return _Onchain.Contract.UintToString(&_Onchain.CallOpts, num)
}

// DeleteBatch is a paid mutator transaction binding the contract method 0xb29e6299.
//
// Solidity: function deleteBatch(bytes16 batchID) returns()
func (_Onchain *OnchainTransactor) DeleteBatch(opts *bind.TransactOpts, batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "deleteBatch", batchID)
}

// DeleteBatch is a paid mutator transaction binding the contract method 0xb29e6299.
//
// Solidity: function deleteBatch(bytes16 batchID) returns()
func (_Onchain *OnchainSession) DeleteBatch(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.DeleteBatch(&_Onchain.TransactOpts, batchID)
}

// DeleteBatch is a paid mutator transaction binding the contract method 0xb29e6299.
//
// Solidity: function deleteBatch(bytes16 batchID) returns()
func (_Onchain *OnchainTransactorSession) DeleteBatch(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.DeleteBatch(&_Onchain.TransactOpts, batchID)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainTransactor) Register(opts *bind.TransactOpts, _m common.Address) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "register", _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainSession) Register(_m common.Address) (*types.Transaction, error) {
	return _Onchain.Contract.Register(&_Onchain.TransactOpts, _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainTransactorSession) Register(_m common.Address) (*types.Transaction, error) {
	return _Onchain.Contract.Register(&_Onchain.TransactOpts, _m)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainTransactor) ReportMissingDeadline(opts *bind.TransactOpts, batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "reportMissingDeadline", batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.ReportMissingDeadline(&_Onchain.TransactOpts, batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainTransactorSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.ReportMissingDeadline(&_Onchain.TransactOpts, batchID)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainTransactor) SendBatch(opts *bind.TransactOpts, batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "sendBatch", batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.Contract.SendBatch(&_Onchain.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainTransactorSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.Contract.SendBatch(&_Onchain.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x123cab3c.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (bytes16,uint256,uint256,bool,bytes,address)[] _ords) returns()
func (_Onchain *OnchainTransactor) SubmitOrderDetails(opts *bind.TransactOpts, batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "submitOrderDetails", batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x123cab3c.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (bytes16,uint256,uint256,bool,bytes,address)[] _ords) returns()
func (_Onchain *OnchainSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.Contract.SubmitOrderDetails(&_Onchain.TransactOpts, batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x123cab3c.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (bytes16,uint256,uint256,bool,bytes,address)[] _ords) returns()
func (_Onchain *OnchainTransactorSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.Contract.SubmitOrderDetails(&_Onchain.TransactOpts, batchID, _ords)
}

// UpdateBatch is a paid mutator transaction binding the contract method 0x82736cd7.
//
// Solidity: function updateBatch(bytes16 batchID, uint256 amount) returns()
func (_Onchain *OnchainTransactor) UpdateBatch(opts *bind.TransactOpts, batchID [16]byte, amount *big.Int) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "updateBatch", batchID, amount)
}

// UpdateBatch is a paid mutator transaction binding the contract method 0x82736cd7.
//
// Solidity: function updateBatch(bytes16 batchID, uint256 amount) returns()
func (_Onchain *OnchainSession) UpdateBatch(batchID [16]byte, amount *big.Int) (*types.Transaction, error) {
	return _Onchain.Contract.UpdateBatch(&_Onchain.TransactOpts, batchID, amount)
}

// UpdateBatch is a paid mutator transaction binding the contract method 0x82736cd7.
//
// Solidity: function updateBatch(bytes16 batchID, uint256 amount) returns()
func (_Onchain *OnchainTransactorSession) UpdateBatch(batchID [16]byte, amount *big.Int) (*types.Transaction, error) {
	return _Onchain.Contract.UpdateBatch(&_Onchain.TransactOpts, batchID, amount)
}

// OnchainAcceptBatchIterator is returned from FilterAcceptBatch and is used to iterate over the raw logs and unpacked data for AcceptBatch events raised by the Onchain contract.
type OnchainAcceptBatchIterator struct {
	Event *OnchainAcceptBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainAcceptBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainAcceptBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainAcceptBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainAcceptBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainAcceptBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainAcceptBatch represents a AcceptBatch event raised by the Onchain contract.
type OnchainAcceptBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAcceptBatch is a free log retrieval operation binding the contract event 0x48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d.
//
// Solidity: event AcceptBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterAcceptBatch(opts *bind.FilterOpts) (*OnchainAcceptBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainAcceptBatchIterator{contract: _Onchain.contract, event: "AcceptBatch", logs: logs, sub: sub}, nil
}

// WatchAcceptBatch is a free log subscription operation binding the contract event 0x48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d.
//
// Solidity: event AcceptBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchAcceptBatch(opts *bind.WatchOpts, sink chan<- *OnchainAcceptBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainAcceptBatch)
				if err := _Onchain.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAcceptBatch is a log parse operation binding the contract event 0x48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d.
//
// Solidity: event AcceptBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseAcceptBatch(log types.Log) (*OnchainAcceptBatch, error) {
	event := new(OnchainAcceptBatch)
	if err := _Onchain.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainFullfilMatchIterator is returned from FilterFullfilMatch and is used to iterate over the raw logs and unpacked data for FullfilMatch events raised by the Onchain contract.
type OnchainFullfilMatchIterator struct {
	Event *OnchainFullfilMatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainFullfilMatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainFullfilMatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainFullfilMatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainFullfilMatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainFullfilMatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainFullfilMatch represents a FullfilMatch event raised by the Onchain contract.
type OnchainFullfilMatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFullfilMatch is a free log retrieval operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterFullfilMatch(opts *bind.FilterOpts) (*OnchainFullfilMatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return &OnchainFullfilMatchIterator{contract: _Onchain.contract, event: "FullfilMatch", logs: logs, sub: sub}, nil
}

// WatchFullfilMatch is a free log subscription operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchFullfilMatch(opts *bind.WatchOpts, sink chan<- *OnchainFullfilMatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainFullfilMatch)
				if err := _Onchain.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFullfilMatch is a log parse operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseFullfilMatch(log types.Log) (*OnchainFullfilMatch, error) {
	event := new(OnchainFullfilMatch)
	if err := _Onchain.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainInvalidBatchIterator is returned from FilterInvalidBatch and is used to iterate over the raw logs and unpacked data for InvalidBatch events raised by the Onchain contract.
type OnchainInvalidBatchIterator struct {
	Event *OnchainInvalidBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainInvalidBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainInvalidBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainInvalidBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainInvalidBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainInvalidBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainInvalidBatch represents a InvalidBatch event raised by the Onchain contract.
type OnchainInvalidBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidBatch is a free log retrieval operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterInvalidBatch(opts *bind.FilterOpts) (*OnchainInvalidBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainInvalidBatchIterator{contract: _Onchain.contract, event: "InvalidBatch", logs: logs, sub: sub}, nil
}

// WatchInvalidBatch is a free log subscription operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchInvalidBatch(opts *bind.WatchOpts, sink chan<- *OnchainInvalidBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainInvalidBatch)
				if err := _Onchain.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidBatch is a log parse operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseInvalidBatch(log types.Log) (*OnchainInvalidBatch, error) {
	event := new(OnchainInvalidBatch)
	if err := _Onchain.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainInvalidOrderIterator is returned from FilterInvalidOrder and is used to iterate over the raw logs and unpacked data for InvalidOrder events raised by the Onchain contract.
type OnchainInvalidOrderIterator struct {
	Event *OnchainInvalidOrder // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainInvalidOrderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainInvalidOrder)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainInvalidOrder)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainInvalidOrderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainInvalidOrderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainInvalidOrder represents a InvalidOrder event raised by the Onchain contract.
type OnchainInvalidOrder struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidOrder is a free log retrieval operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterInvalidOrder(opts *bind.FilterOpts) (*OnchainInvalidOrderIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return &OnchainInvalidOrderIterator{contract: _Onchain.contract, event: "InvalidOrder", logs: logs, sub: sub}, nil
}

// WatchInvalidOrder is a free log subscription operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchInvalidOrder(opts *bind.WatchOpts, sink chan<- *OnchainInvalidOrder) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainInvalidOrder)
				if err := _Onchain.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidOrder is a log parse operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseInvalidOrder(log types.Log) (*OnchainInvalidOrder, error) {
	event := new(OnchainInvalidOrder)
	if err := _Onchain.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the Onchain contract.
type OnchainLogAddressIterator struct {
	Event *OnchainLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogAddress represents a LogAddress event raised by the Onchain contract.
type OnchainLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) FilterLogAddress(opts *bind.FilterOpts) (*OnchainLogAddressIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return &OnchainLogAddressIterator{contract: _Onchain.contract, event: "LogAddress", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *OnchainLogAddress) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogAddress)
				if err := _Onchain.contract.UnpackLog(event, "LogAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) ParseLogAddress(log types.Log) (*OnchainLogAddress, error) {
	event := new(OnchainLogAddress)
	if err := _Onchain.contract.UnpackLog(event, "LogAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the Onchain contract.
type OnchainLogBytesIterator struct {
	Event *OnchainLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes represents a LogBytes event raised by the Onchain contract.
type OnchainLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes(opts *bind.FilterOpts) (*OnchainLogBytesIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytesIterator{contract: _Onchain.contract, event: "LogBytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes(log types.Log) (*OnchainLogBytes, error) {
	event := new(OnchainLogBytes)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytes16Iterator is returned from FilterLogBytes16 and is used to iterate over the raw logs and unpacked data for LogBytes16 events raised by the Onchain contract.
type OnchainLogBytes16Iterator struct {
	Event *OnchainLogBytes16 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytes16Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes16)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes16)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytes16Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytes16Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes16 represents a LogBytes16 event raised by the Onchain contract.
type OnchainLogBytes16 struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes16 is a free log retrieval operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes16(opts *bind.FilterOpts) (*OnchainLogBytes16Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytes16Iterator{contract: _Onchain.contract, event: "LogBytes16", logs: logs, sub: sub}, nil
}

// WatchLogBytes16 is a free log subscription operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes16(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes16) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes16)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes16", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes16 is a log parse operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes16(log types.Log) (*OnchainLogBytes16, error) {
	event := new(OnchainLogBytes16)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes16", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the Onchain contract.
type OnchainLogBytes32Iterator struct {
	Event *OnchainLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes32 represents a LogBytes32 event raised by the Onchain contract.
type OnchainLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*OnchainLogBytes32Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytes32Iterator{contract: _Onchain.contract, event: "LogBytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes32) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes32)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes32(log types.Log) (*OnchainLogBytes32, error) {
	event := new(OnchainLogBytes32)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogRecoverErrorIterator is returned from FilterLogRecoverError and is used to iterate over the raw logs and unpacked data for LogRecoverError events raised by the Onchain contract.
type OnchainLogRecoverErrorIterator struct {
	Event *OnchainLogRecoverError // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogRecoverErrorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogRecoverError)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogRecoverError)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogRecoverErrorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogRecoverErrorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogRecoverError represents a LogRecoverError event raised by the Onchain contract.
type OnchainLogRecoverError struct {
	Arg0 uint8
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogRecoverError is a free log retrieval operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) FilterLogRecoverError(opts *bind.FilterOpts) (*OnchainLogRecoverErrorIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return &OnchainLogRecoverErrorIterator{contract: _Onchain.contract, event: "LogRecoverError", logs: logs, sub: sub}, nil
}

// WatchLogRecoverError is a free log subscription operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) WatchLogRecoverError(opts *bind.WatchOpts, sink chan<- *OnchainLogRecoverError) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogRecoverError)
				if err := _Onchain.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogRecoverError is a log parse operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) ParseLogRecoverError(log types.Log) (*OnchainLogRecoverError, error) {
	event := new(OnchainLogRecoverError)
	if err := _Onchain.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the Onchain contract.
type OnchainLogStringIterator struct {
	Event *OnchainLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogString represents a LogString event raised by the Onchain contract.
type OnchainLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) FilterLogString(opts *bind.FilterOpts) (*OnchainLogStringIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return &OnchainLogStringIterator{contract: _Onchain.contract, event: "LogString", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *OnchainLogString) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogString)
				if err := _Onchain.contract.UnpackLog(event, "LogString", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) ParseLogString(log types.Log) (*OnchainLogString, error) {
	event := new(OnchainLogString)
	if err := _Onchain.contract.UnpackLog(event, "LogString", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainPartialMatchIterator is returned from FilterPartialMatch and is used to iterate over the raw logs and unpacked data for PartialMatch events raised by the Onchain contract.
type OnchainPartialMatchIterator struct {
	Event *OnchainPartialMatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainPartialMatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainPartialMatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainPartialMatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainPartialMatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainPartialMatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainPartialMatch represents a PartialMatch event raised by the Onchain contract.
type OnchainPartialMatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPartialMatch is a free log retrieval operation binding the contract event 0xcb56a4fd10f2bad2015ad7e01fb83de3e6d71a6f46eef88ebe216fd70f25efd4.
//
// Solidity: event PartialMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterPartialMatch(opts *bind.FilterOpts) (*OnchainPartialMatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "PartialMatch")
	if err != nil {
		return nil, err
	}
	return &OnchainPartialMatchIterator{contract: _Onchain.contract, event: "PartialMatch", logs: logs, sub: sub}, nil
}

// WatchPartialMatch is a free log subscription operation binding the contract event 0xcb56a4fd10f2bad2015ad7e01fb83de3e6d71a6f46eef88ebe216fd70f25efd4.
//
// Solidity: event PartialMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchPartialMatch(opts *bind.WatchOpts, sink chan<- *OnchainPartialMatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "PartialMatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainPartialMatch)
				if err := _Onchain.contract.UnpackLog(event, "PartialMatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePartialMatch is a log parse operation binding the contract event 0xcb56a4fd10f2bad2015ad7e01fb83de3e6d71a6f46eef88ebe216fd70f25efd4.
//
// Solidity: event PartialMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParsePartialMatch(log types.Log) (*OnchainPartialMatch, error) {
	event := new(OnchainPartialMatch)
	if err := _Onchain.contract.UnpackLog(event, "PartialMatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainPunishMatcherIterator is returned from FilterPunishMatcher and is used to iterate over the raw logs and unpacked data for PunishMatcher events raised by the Onchain contract.
type OnchainPunishMatcherIterator struct {
	Event *OnchainPunishMatcher // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainPunishMatcherIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainPunishMatcher)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainPunishMatcher)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainPunishMatcherIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainPunishMatcherIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainPunishMatcher represents a PunishMatcher event raised by the Onchain contract.
type OnchainPunishMatcher struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPunishMatcher is a free log retrieval operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) FilterPunishMatcher(opts *bind.FilterOpts) (*OnchainPunishMatcherIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return &OnchainPunishMatcherIterator{contract: _Onchain.contract, event: "PunishMatcher", logs: logs, sub: sub}, nil
}

// WatchPunishMatcher is a free log subscription operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) WatchPunishMatcher(opts *bind.WatchOpts, sink chan<- *OnchainPunishMatcher) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainPunishMatcher)
				if err := _Onchain.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePunishMatcher is a log parse operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) ParsePunishMatcher(log types.Log) (*OnchainPunishMatcher, error) {
	event := new(OnchainPunishMatcher)
	if err := _Onchain.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainReceivedBatchDetailsIterator is returned from FilterReceivedBatchDetails and is used to iterate over the raw logs and unpacked data for ReceivedBatchDetails events raised by the Onchain contract.
type OnchainReceivedBatchDetailsIterator struct {
	Event *OnchainReceivedBatchDetails // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainReceivedBatchDetailsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainReceivedBatchDetails)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainReceivedBatchDetails)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainReceivedBatchDetailsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainReceivedBatchDetailsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainReceivedBatchDetails represents a ReceivedBatchDetails event raised by the Onchain contract.
type OnchainReceivedBatchDetails struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterReceivedBatchDetails is a free log retrieval operation binding the contract event 0x9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterReceivedBatchDetails(opts *bind.FilterOpts) (*OnchainReceivedBatchDetailsIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return &OnchainReceivedBatchDetailsIterator{contract: _Onchain.contract, event: "ReceivedBatchDetails", logs: logs, sub: sub}, nil
}

// WatchReceivedBatchDetails is a free log subscription operation binding the contract event 0x9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchReceivedBatchDetails(opts *bind.WatchOpts, sink chan<- *OnchainReceivedBatchDetails) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainReceivedBatchDetails)
				if err := _Onchain.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseReceivedBatchDetails is a log parse operation binding the contract event 0x9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseReceivedBatchDetails(log types.Log) (*OnchainReceivedBatchDetails, error) {
	event := new(OnchainReceivedBatchDetails)
	if err := _Onchain.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainRemoveBatchOutOfDateIterator is returned from FilterRemoveBatchOutOfDate and is used to iterate over the raw logs and unpacked data for RemoveBatchOutOfDate events raised by the Onchain contract.
type OnchainRemoveBatchOutOfDateIterator struct {
	Event *OnchainRemoveBatchOutOfDate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainRemoveBatchOutOfDateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainRemoveBatchOutOfDate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainRemoveBatchOutOfDate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainRemoveBatchOutOfDateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainRemoveBatchOutOfDateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainRemoveBatchOutOfDate represents a RemoveBatchOutOfDate event raised by the Onchain contract.
type OnchainRemoveBatchOutOfDate struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRemoveBatchOutOfDate is a free log retrieval operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterRemoveBatchOutOfDate(opts *bind.FilterOpts) (*OnchainRemoveBatchOutOfDateIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return &OnchainRemoveBatchOutOfDateIterator{contract: _Onchain.contract, event: "RemoveBatchOutOfDate", logs: logs, sub: sub}, nil
}

// WatchRemoveBatchOutOfDate is a free log subscription operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchRemoveBatchOutOfDate(opts *bind.WatchOpts, sink chan<- *OnchainRemoveBatchOutOfDate) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainRemoveBatchOutOfDate)
				if err := _Onchain.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRemoveBatchOutOfDate is a log parse operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseRemoveBatchOutOfDate(log types.Log) (*OnchainRemoveBatchOutOfDate, error) {
	event := new(OnchainRemoveBatchOutOfDate)
	if err := _Onchain.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainRevertBatchIterator is returned from FilterRevertBatch and is used to iterate over the raw logs and unpacked data for RevertBatch events raised by the Onchain contract.
type OnchainRevertBatchIterator struct {
	Event *OnchainRevertBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainRevertBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainRevertBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainRevertBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainRevertBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainRevertBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainRevertBatch represents a RevertBatch event raised by the Onchain contract.
type OnchainRevertBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRevertBatch is a free log retrieval operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterRevertBatch(opts *bind.FilterOpts) (*OnchainRevertBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainRevertBatchIterator{contract: _Onchain.contract, event: "RevertBatch", logs: logs, sub: sub}, nil
}

// WatchRevertBatch is a free log subscription operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchRevertBatch(opts *bind.WatchOpts, sink chan<- *OnchainRevertBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainRevertBatch)
				if err := _Onchain.contract.UnpackLog(event, "RevertBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRevertBatch is a log parse operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseRevertBatch(log types.Log) (*OnchainRevertBatch, error) {
	event := new(OnchainRevertBatch)
	if err := _Onchain.contract.UnpackLog(event, "RevertBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
