// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package onchain

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// OnchainOrder is an auto generated low-level Go binding around an user-defined struct.
type OnchainOrder struct {
	Price             *big.Int
	Amount            *big.Int
	Side              bool
	From              [16]byte
	TradeHash         [32]byte
	OriginalOrderHash [32]byte
	Owner             common.Address
}

// OnchainMetaData contains all meta data concerning the Onchain contract.
var OnchainMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"StringsInsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"AcceptBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BatchMatchAmountAndProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BatchRawProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BatchTimestamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"FullfilMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"LogBytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"LogBytes16\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"LogBytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumECDSA.RecoverError\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"LogRecoverError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LogUint256\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MatchedPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PunishMatcher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ReceivedBatchDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RemoveBatchOutOfDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RevertBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"ValidMatching\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"isMatcher\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"isPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"bidBatchID\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"askBatchID\",\"type\":\"bytes16\"}],\"name\":\"matching\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"reportMissingDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sign\",\"type\":\"bytes\"}],\"name\":\"sendBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"bytes16\",\"name\":\"from\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"originalOrderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"structOnchain.Order[]\",\"name\":\"_ords\",\"type\":\"tuple[]\"}],\"name\":\"submitOrderDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"uintToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x608060405234801562000010575f80fd5b506040516200451e3803806200451e833981810160405281019062000036919062000138565b8060075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550670de0b6b3a76400005f81905550603c6001819055503360085f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505062000168565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6200010282620000d7565b9050919050565b6200011481620000f6565b81146200011f575f80fd5b50565b5f81519050620001328162000109565b92915050565b5f6020828403121562000150576200014f620000d3565b5b5f6200015f8482850162000122565b91505092915050565b6143a880620001765f395ff3fe6080604052600436106100a6575f3560e01c806336ee67491161006357806336ee6749146101925780634420e486146101ce5780634dcbd09b146101ea5780635e57966d1461021457806378b32cf514610250578063e939567914610278576100a6565b80630c145e73146100aa5780630ffde4c5146100d257806319f5e9fe146100fa5780632a096397146101365780633005d34c1461014057806332a58e7914610168575b5f80fd5b3480156100b5575f80fd5b506100d060048036038101906100cb91906130a3565b6102b4565b005b3480156100dd575f80fd5b506100f860048036038101906100f391906133db565b610c08565b005b348015610105575f80fd5b50610120600480360381019061011b9190613435565b611f43565b60405161012d919061346f565b60405180910390f35b61013e611fdb565b005b34801561014b575f80fd5b5061016660048036038101906101619190613538565b61201f565b005b348015610173575f80fd5b5061017c6120cb565b60405161018991906135ec565b60405180910390f35b34801561019d575f80fd5b506101b860048036038101906101b39190613605565b6120d3565b6040516101c5919061346f565b60405180910390f35b6101e860048036038101906101e39190613605565b61211c565b005b3480156101f5575f80fd5b506101fe6121a6565b60405161020b91906135ec565b60405180910390f35b34801561021f575f80fd5b5061023a60048036038101906102359190613605565b6121af565b60405161024791906136aa565b60405180910390f35b34801561025b575f80fd5b5061027660048036038101906102719190613435565b6121d9565b005b348015610283575f80fd5b5061029e600480360381019061029991906136ca565b61252c565b6040516102ab91906136aa565b60405180910390f35b815f73ffffffffffffffffffffffffffffffffffffffff1660035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361037d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103749061373f565b60405180910390fd5b815f73ffffffffffffffffffffffffffffffffffffffff1660035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610446576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161043d9061373f565b60405180910390fd5b5f60035f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016004820180546105589061378a565b80601f01602080910402602001604051908101604052809291908181526020018280546105849061378a565b80156105cf5780601f106105a6576101008083540402835291602001916105cf565b820191905f5260205f20905b8154815290600101906020018083116105b257829003601f168201915b5050505050815260200160058201548152505090505f60035f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016004820180546106f69061378a565b80601f01602080910402602001604051908101604052809291908181526020018280546107229061378a565b801561076d5780601f106107445761010080835404028352916020019161076d565b820191905f5260205f20905b81548152906001019060200180831161075057829003601f168201915b505050505081526020016005820154815250509050856fffffffffffffffffffffffffffffffff1916825f01516fffffffffffffffffffffffffffffffff1916146107ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107e490613804565b60405180910390fd5b5f8260c0015114610833576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082a9061386c565b60405180910390fd5b846fffffffffffffffffffffffffffffffff1916815f01516fffffffffffffffffffffffffffffffff19161461089e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610895906138d4565b60405180910390fd5b5f8160c00151146108e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108db9061393c565b60405180910390fd5b8060200151826020015110158015610903575080604001518260400151145b15610c00575f60028260200151846020015161091f9190613987565b61092991906139e7565b90507f99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c83604001518285602001516109619190613a17565b60405161096f929190613a4a565b60405180910390a17fe815d3dc17143b69b6fb9905c4f0a0da9afaecfbda798ab64633b254ce53017a835f01518285602001516109ac9190613a17565b6040516109ba929190613a80565b60405180910390a17fe815d3dc17143b69b6fb9905c4f0a0da9afaecfbda798ab64633b254ce53017a825f01518285602001516109f79190613a17565b604051610a05929190613a80565b60405180910390a17f21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e781604051610a3c91906135ec565b60405180910390a14260035f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055504260035f886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050181905550815f015160045f855f01516fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c0217905550825f015160045f845f01516fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055507f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965835f0151604051610bbc9190613aa7565b60405180910390a17f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965825f0151604051610bf69190613aa7565b60405180910390a1505b505050505050565b815f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015403610c85576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c7c90613b0a565b60405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d4e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d4590613b72565b60405180910390fd5b7f6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f6688442604051610d7f929190613a80565b60405180910390a15f60605f5b85518160ff161015610ef357858160ff1681518110610dae57610dad613b90565b5b60200260200101516020015183610dc59190613987565b925081868260ff1681518110610dde57610ddd613b90565b5b60200260200101515f0151878360ff1681518110610dff57610dfe613b90565b5b602002602001015160200151888460ff1681518110610e2157610e20613b90565b5b602002602001015160400151898560ff1681518110610e4357610e42613b90565b5b602002602001015160600151604051602001610e629493929190613c42565b60405160208183030381529060405280519060200120878360ff1681518110610e8e57610e8d613b90565b5b602002602001015160800151888460ff1681518110610eb057610eaf613b90565b5b602002602001015160a00151604051602001610ecf9493929190613cf3565b60405160208183030381529060405291508080610eeb90613d48565b915050610d8c565b5060035f876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600201548214610f73577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad74886604051610f649190613aa7565b60405180910390a15050611f3d565b5f6111858760035f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206001015460035f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002015460035f8c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff168a518760035f8f6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516020016110a99796959493929190613dcc565b6040516020818303038152906040528051906020012060035f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060040180546111049061378a565b80601f01602080910402602001604051908101604052809291908181526020018280546111309061378a565b801561117b5780601f106111525761010080835404028352916020019161117b565b820191905f5260205f20905b81548152906001019060200180831161115e57829003601f168201915b505050505061253e565b905060035f886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611253577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748876040516112439190613aa7565b60405180910390a1505050611f3d565b5f60065f60045f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2080549050036114b0575f5b86518160ff1610156114aa575f604051806080016040528060035f8c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600101548152602001898460ff168151811061134757611346613b90565b5b6020026020010151602001518152602001898460ff168151811061136e5761136d613b90565b5b60200260200101516040015115158152602001898460ff168151811061139757611396613b90565b5b602002602001015160c0015173ffffffffffffffffffffffffffffffffffffffff16815250905060065f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2081908060018154018082558091505060019003905f5260205f2090600302015f909190919091505f820151815f0155602082015181600101556040820151816002015f6101000a81548160ff02191690831515021790555060608201518160020160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505080806114a290613d48565b9150506112d9565b50611ec0565b7fd34b097bfa1e657b66a63bd1147719fd1b7022724f5a33cb87e99c4764ab8c02876040516114df9190613aa7565b60405180910390a17fd34b097bfa1e657b66a63bd1147719fd1b7022724f5a33cb87e99c4764ab8c0260045f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6040516115599190613aa7565b60405180910390a15f60065f60045f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20805480602002602001604051908101604052809291908181526020015f905b828210156116ae578382905f5260205f2090600302016040518060800160405290815f820154815260200160018201548152602001600282015f9054906101000a900460ff161515151581526020016002820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050815260200190600101906115fb565b5050505090505f81511180156116e6575060011515815f815181106116d6576116d5613b90565b5b6020026020010151604001511515145b156118d4575f5b81518160ff1610156118ce57818160ff168151811061170f5761170e613b90565b5b602002602001015160200151828260ff168151811061173157611730613b90565b5b60200260200101515f01516117469190613e48565b60055f848460ff168151811061175f5761175e613b90565b5b60200260200101516060015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8282546117b29190613a17565b9250508190555060075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd60085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16848460ff168151811061182e5761182d613b90565b5b602002602001015160600151858560ff16815181106118505761184f613b90565b5b6020026020010151602001516040518463ffffffff1660e01b815260040161187a93929190613e98565b6020604051808303815f875af1158015611896573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118ba9190613ee1565b5080806118c690613d48565b9150506116ed565b50611ab9565b5f5b81518160ff161015611ab75760075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd838360ff168151811061193557611934613b90565b5b60200260200101516060015160085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16858560ff168151811061197957611978613b90565b5b6020026020010151602001516040518463ffffffff1660e01b81526004016119a393929190613e98565b6020604051808303815f875af11580156119bf573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119e39190613ee1565b50818160ff16815181106119fa576119f9613b90565b5b602002602001015160200151828260ff1681518110611a1c57611a1b613b90565b5b60200260200101515f0151611a319190613e48565b60055f848460ff1681518110611a4a57611a49613b90565b5b60200260200101516060015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254611a9d9190613987565b925050819055508080611aaf90613d48565b9150506118d6565b505b5f8751118015611aeb575060011515875f81518110611adb57611ada613b90565b5b6020026020010151604001511515145b15611cd9575f5b87518160ff161015611cd357878160ff1681518110611b1457611b13613b90565b5b602002602001015160200151888260ff1681518110611b3657611b35613b90565b5b60200260200101515f0151611b4b9190613e48565b60055f8a8460ff1681518110611b6457611b63613b90565b5b602002602001015160c0015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254611bb79190613a17565b9250508190555060075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd60085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff168a8460ff1681518110611c3357611c32613b90565b5b602002602001015160c001518b8560ff1681518110611c5557611c54613b90565b5b6020026020010151602001516040518463ffffffff1660e01b8152600401611c7f93929190613e98565b6020604051808303815f875af1158015611c9b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611cbf9190613ee1565b508080611ccb90613d48565b915050611af2565b50611ebe565b5f5b87518160ff161015611ebc5760075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd898360ff1681518110611d3a57611d39613b90565b5b602002602001015160c0015160085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff168b8560ff1681518110611d7e57611d7d613b90565b5b6020026020010151602001516040518463ffffffff1660e01b8152600401611da893929190613e98565b6020604051808303815f875af1158015611dc4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611de89190613ee1565b50878160ff1681518110611dff57611dfe613b90565b5b602002602001015160200151888260ff1681518110611e2157611e20613b90565b5b60200260200101515f0151611e369190613e48565b60055f8a8460ff1681518110611e4f57611e4e613b90565b5b602002602001015160c0015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254611ea29190613987565b925050819055508080611eb490613d48565b915050611cdb565b505b505b5f60035f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055507fd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b878751604051611f31929190613a80565b60405180910390a15050505b50505050565b5f8060035f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015414158015611fd457504260015460035f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154611fd29190613987565b105b9050919050565b3460055f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550565b7f6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f6688642604051612050929190613a80565b60405180910390a15f6040518060e00160405280886fffffffffffffffffffffffffffffffff1916815260200187815260200186815260200185151581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018381526020015f81525090506120c281612568565b50505050505050565b5f8054905090565b5f8060025f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205414159050919050565b5f54341015612160576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161215790613f56565b60405180910390fd5b5f5460025f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208190555050565b5f600154905090565b60606121d28273ffffffffffffffffffffffffffffffffffffffff1660146126bc565b9050919050565b805f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015403612256576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161224d90613b0a565b60405180910390fd5b4260015460035f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015461229f9190613987565b106122df576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016122d690613fbe565b60405180910390fd5b5f60025f60035f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055505f60035f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055505f60045f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b905060045f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154906fffffffffffffffffffffffffffffffff021916905561245f816128fa565b7fef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b6602208360405161248e9190613aa7565b60405180910390a17f5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba2360035f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660405161251f9190613fdc565b60405180910390a1505050565b606061253782612b84565b9050919050565b5f805f8061254c8686612c4e565b92509250925061255c8282612ca3565b82935050505092915050565b7f4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd815f01518260200151836040015184606001516040516125ac9493929190613ff5565b60405180910390a18060035f835f01516fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f820151815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555060208201518160010155604082015181600201556060820151816003015f6101000a81548160ff02191690831515021790555060808201518160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060a08201518160040190816126ab91906141d5565b5060c0820151816005015590505050565b60605f8390505f60028460026126d29190613e48565b6126dc9190613987565b67ffffffffffffffff8111156126f5576126f46130f5565b5b6040519080825280601f01601f1916602001820160405280156127275781602001600182028036833780820191505090505b5090507f3000000000000000000000000000000000000000000000000000000000000000815f8151811061275e5761275d613b90565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053507f7800000000000000000000000000000000000000000000000000000000000000816001815181106127c1576127c0613b90565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505f60018560026127ff9190613e48565b6128099190613987565b90505b60018111156128a8577f3031323334353637383961626364656600000000000000000000000000000000600f84166010811061284b5761284a613b90565b5b1a60f81b82828151811061286257612861613b90565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600483901c9250806128a1906142a4565b905061280c565b505f82146128ef5784846040517fe22e27eb0000000000000000000000000000000000000000000000000000000081526004016128e6929190613a4a565b60405180910390fd5b809250505092915050565b5f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015414801561299c57505f60801b60045f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff191614155b15612b81577ff335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6816040516129d09190613aa7565b60405180910390a15f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600482018054612aea9061378a565b80601f0160208091040260200160405190810160405280929190818152602001828054612b169061378a565b8015612b615780601f10612b3857610100808354040283529160200191612b61565b820191905f5260205f20905b815481529060010190602001808311612b4457829003601f168201915b505050505081526020016005820154815250509050612b7f81612568565b505b50565b60605f6001612b9284612e05565b0190505f8167ffffffffffffffff811115612bb057612baf6130f5565b5b6040519080825280601f01601f191660200182016040528015612be25781602001600182028036833780820191505090505b5090505f82602001820190505b600115612c43578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612c3857612c376139ba565b5b0494505f8503612bef575b819350505050919050565b5f805f6041845103612c8e575f805f602087015192506040870151915060608701515f1a9050612c8088828585612f56565b955095509550505050612c9c565b5f600285515f1b9250925092505b9250925092565b5f6003811115612cb657612cb56142cb565b5b826003811115612cc957612cc86142cb565b5b0315612e015760016003811115612ce357612ce26142cb565b5b826003811115612cf657612cf56142cb565b5b03612d2d576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115612d4157612d406142cb565b5b826003811115612d5457612d536142cb565b5b03612d9857805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401612d8f91906135ec565b60405180910390fd5b600380811115612dab57612daa6142cb565b5b826003811115612dbe57612dbd6142cb565b5b03612e0057806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401612df79190614307565b60405180910390fd5b5b5050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612e61577a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008381612e5757612e566139ba565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310612e9e576d04ee2d6d415b85acef81000000008381612e9457612e936139ba565b5b0492506020810190505b662386f26fc100008310612ecd57662386f26fc100008381612ec357612ec26139ba565b5b0492506010810190505b6305f5e1008310612ef6576305f5e1008381612eec57612eeb6139ba565b5b0492506008810190505b6127108310612f1b576127108381612f1157612f106139ba565b5b0492506004810190505b60648310612f3e5760648381612f3457612f336139ba565b5b0492506002810190505b600a8310612f4d576001810190505b80915050919050565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115612f92575f600385925092509250613033565b5f6001888888886040515f8152602001604052604051612fb5949392919061432f565b6020604051602081039080840390855afa158015612fd5573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603613026575f60015f801b93509350935050613033565b805f805f1b935093509350505b9450945094915050565b5f604051905090565b5f80fd5b5f80fd5b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6130828161304e565b811461308c575f80fd5b50565b5f8135905061309d81613079565b92915050565b5f80604083850312156130b9576130b8613046565b5b5f6130c68582860161308f565b92505060206130d78582860161308f565b9150509250929050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61312b826130e5565b810181811067ffffffffffffffff8211171561314a576131496130f5565b5b80604052505050565b5f61315c61303d565b90506131688282613122565b919050565b5f67ffffffffffffffff821115613187576131866130f5565b5b602082029050602081019050919050565b5f80fd5b5f80fd5b5f819050919050565b6131b2816131a0565b81146131bc575f80fd5b50565b5f813590506131cd816131a9565b92915050565b5f8115159050919050565b6131e7816131d3565b81146131f1575f80fd5b50565b5f81359050613202816131de565b92915050565b5f819050919050565b61321a81613208565b8114613224575f80fd5b50565b5f8135905061323581613211565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6132648261323b565b9050919050565b6132748161325a565b811461327e575f80fd5b50565b5f8135905061328f8161326b565b92915050565b5f60e082840312156132aa576132a961319c565b5b6132b460e0613153565b90505f6132c3848285016131bf565b5f8301525060206132d6848285016131bf565b60208301525060406132ea848285016131f4565b60408301525060606132fe8482850161308f565b606083015250608061331284828501613227565b60808301525060a061332684828501613227565b60a08301525060c061333a84828501613281565b60c08301525092915050565b5f6133586133538461316d565b613153565b90508083825260208201905060e0840283018581111561337b5761337a613198565b5b835b818110156133a457806133908882613295565b84526020840193505060e08101905061337d565b5050509392505050565b5f82601f8301126133c2576133c16130e1565b5b81356133d2848260208601613346565b91505092915050565b5f80604083850312156133f1576133f0613046565b5b5f6133fe8582860161308f565b925050602083013567ffffffffffffffff81111561341f5761341e61304a565b5b61342b858286016133ae565b9150509250929050565b5f6020828403121561344a57613449613046565b5b5f6134578482850161308f565b91505092915050565b613469816131d3565b82525050565b5f6020820190506134825f830184613460565b92915050565b5f80fd5b5f67ffffffffffffffff8211156134a6576134a56130f5565b5b6134af826130e5565b9050602081019050919050565b828183375f83830152505050565b5f6134dc6134d78461348c565b613153565b9050828152602081018484840111156134f8576134f7613488565b5b6135038482856134bc565b509392505050565b5f82601f83011261351f5761351e6130e1565b5b813561352f8482602086016134ca565b91505092915050565b5f805f805f8060c0878903121561355257613551613046565b5b5f61355f89828a0161308f565b965050602061357089828a016131bf565b955050604061358189828a016131bf565b945050606061359289828a016131f4565b93505060806135a389828a01613281565b92505060a087013567ffffffffffffffff8111156135c4576135c361304a565b5b6135d089828a0161350b565b9150509295509295509295565b6135e6816131a0565b82525050565b5f6020820190506135ff5f8301846135dd565b92915050565b5f6020828403121561361a57613619613046565b5b5f61362784828501613281565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b8381101561366757808201518184015260208101905061364c565b5f8484015250505050565b5f61367c82613630565b613686818561363a565b935061369681856020860161364a565b61369f816130e5565b840191505092915050565b5f6020820190508181035f8301526136c28184613672565b905092915050565b5f602082840312156136df576136de613046565b5b5f6136ec848285016131bf565b91505092915050565b7f74686520626174636820646f6573206e6f7420657869737400000000000000005f82015250565b5f61372960188361363a565b9150613734826136f5565b602082019050919050565b5f6020820190508181035f8301526137568161371d565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806137a157607f821691505b6020821081036137b4576137b361375d565b5b50919050565b7f62696420626174636820646f65736e27742065787369740000000000000000005f82015250565b5f6137ee60178361363a565b91506137f9826137ba565b602082019050919050565b5f6020820190508181035f83015261381b816137e2565b9050919050565b7f6269642062617463682069732070656e64696e670000000000000000000000005f82015250565b5f61385660148361363a565b915061386182613822565b602082019050919050565b5f6020820190508181035f8301526138838161384a565b9050919050565b7f61736b206261746368206f6465736e27742065787369740000000000000000005f82015250565b5f6138be60178361363a565b91506138c98261388a565b602082019050919050565b5f6020820190508181035f8301526138eb816138b2565b9050919050565b7f61736b2062617463682069732070656e64696e670000000000000000000000005f82015250565b5f61392660148361363a565b9150613931826138f2565b602082019050919050565b5f6020820190508181035f8301526139538161391a565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f613991826131a0565b915061399c836131a0565b92508282019050808211156139b4576139b361395a565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6139f1826131a0565b91506139fc836131a0565b925082613a0c57613a0b6139ba565b5b828204905092915050565b5f613a21826131a0565b9150613a2c836131a0565b9250828203905081811115613a4457613a4361395a565b5b92915050565b5f604082019050613a5d5f8301856135dd565b613a6a60208301846135dd565b9392505050565b613a7a8161304e565b82525050565b5f604082019050613a935f830185613a71565b613aa060208301846135dd565b9392505050565b5f602082019050613aba5f830184613a71565b92915050565b7f746865206261746368206973206e6f742070656e64696e6700000000000000005f82015250565b5f613af460188361363a565b9150613aff82613ac0565b602082019050919050565b5f6020820190508181035f830152613b2181613ae8565b9050919050565b7f726571756972652062617463682773206f0000000000000000000000000000005f82015250565b5f613b5c60118361363a565b9150613b6782613b28565b602082019050919050565b5f6020820190508181035f830152613b8981613b50565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f819050919050565b613bd7613bd2826131a0565b613bbd565b82525050565b5f8160f81b9050919050565b5f613bf382613bdd565b9050919050565b5f613c0482613be9565b9050919050565b613c1c613c17826131d3565b613bfa565b82525050565b5f819050919050565b613c3c613c378261304e565b613c22565b82525050565b5f613c4d8287613bc6565b602082019150613c5d8286613bc6565b602082019150613c6d8285613c0b565b600182019150613c7d8284613c2b565b60108201915081905095945050505050565b5f81519050919050565b5f81905092915050565b5f613cad82613c8f565b613cb78185613c99565b9350613cc781856020860161364a565b80840191505092915050565b5f819050919050565b613ced613ce882613208565b613cd3565b82525050565b5f613cfe8287613ca3565b9150613d0a8286613cdc565b602082019150613d1a8285613cdc565b602082019150613d2a8284613cdc565b60208201915081905095945050505050565b5f60ff82169050919050565b5f613d5282613d3c565b915060ff8203613d6557613d6461395a565b5b600182019050919050565b613d81613d7c82613d3c565b613be9565b82525050565b5f8160601b9050919050565b5f613d9d82613d87565b9050919050565b5f613dae82613d93565b9050919050565b613dc6613dc18261325a565b613da4565b82525050565b5f613dd7828a613c2b565b601082019150613de78289613bc6565b602082019150613df78288613bc6565b602082019150613e078287613c0b565b600182019150613e178286613d70565b600182019150613e278285613ca3565b9150613e338284613db5565b60148201915081905098975050505050505050565b5f613e52826131a0565b9150613e5d836131a0565b9250828202613e6b816131a0565b91508282048414831517613e8257613e8161395a565b5b5092915050565b613e928161325a565b82525050565b5f606082019050613eab5f830186613e89565b613eb86020830185613e89565b613ec560408301846135dd565b949350505050565b5f81519050613edb816131de565b92915050565b5f60208284031215613ef657613ef5613046565b5b5f613f0384828501613ecd565b91505092915050565b7f726567697374657220666565206973206e6f7420656e6f7567680000000000005f82015250565b5f613f40601a8361363a565b9150613f4b82613f0c565b602082019050919050565b5f6020820190508181035f830152613f6d81613f34565b9050919050565b7f746865206261746368206973206e6f74206f75742d6f662d64617465000000005f82015250565b5f613fa8601c8361363a565b9150613fb382613f74565b602082019050919050565b5f6020820190508181035f830152613fd581613f9c565b9050919050565b5f602082019050613fef5f830184613e89565b92915050565b5f6080820190506140085f830187613a71565b61401560208301866135dd565b61402260408301856135dd565b61402f6060830184613460565b95945050505050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026140947fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82614059565b61409e8683614059565b95508019841693508086168417925050509392505050565b5f819050919050565b5f6140d96140d46140cf846131a0565b6140b6565b6131a0565b9050919050565b5f819050919050565b6140f2836140bf565b6141066140fe826140e0565b848454614065565b825550505050565b5f90565b61411a61410e565b6141258184846140e9565b505050565b5b818110156141485761413d5f82614112565b60018101905061412b565b5050565b601f82111561418d5761415e81614038565b6141678461404a565b81016020851015614176578190505b61418a6141828561404a565b83018261412a565b50505b505050565b5f82821c905092915050565b5f6141ad5f1984600802614192565b1980831691505092915050565b5f6141c5838361419e565b9150826002028217905092915050565b6141de82613c8f565b67ffffffffffffffff8111156141f7576141f66130f5565b5b614201825461378a565b61420c82828561414c565b5f60209050601f83116001811461423d575f841561422b578287015190505b61423585826141ba565b86555061429c565b601f19841661424b86614038565b5f5b828110156142725784890151825560018201915060208501945060208101905061424d565b8683101561428f578489015161428b601f89168261419e565b8355505b6001600288020188555050505b505050505050565b5f6142ae826131a0565b91505f82036142c0576142bf61395a565b5b600182039050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b61430181613208565b82525050565b5f60208201905061431a5f8301846142f8565b92915050565b61432981613d3c565b82525050565b5f6080820190506143425f8301876142f8565b61434f6020830186614320565b61435c60408301856142f8565b61436960608301846142f8565b9594505050505056fea2646970667358221220410c325d66caf8150096d8bf1a18b629617795836572a1b383ccda60375b877964736f6c63430008180033",
}

// OnchainABI is the input ABI used to generate the binding from.
// Deprecated: Use OnchainMetaData.ABI instead.
var OnchainABI = OnchainMetaData.ABI

// OnchainBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OnchainMetaData.Bin instead.
var OnchainBin = OnchainMetaData.Bin

// DeployOnchain deploys a new Ethereum contract, binding an instance of Onchain to it.
func DeployOnchain(auth *bind.TransactOpts, backend bind.ContractBackend, _token common.Address) (common.Address, *types.Transaction, *Onchain, error) {
	parsed, err := OnchainMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OnchainBin), backend, _token)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Onchain{OnchainCaller: OnchainCaller{contract: contract}, OnchainTransactor: OnchainTransactor{contract: contract}, OnchainFilterer: OnchainFilterer{contract: contract}}, nil
}

// Onchain is an auto generated Go binding around an Ethereum contract.
type Onchain struct {
	OnchainCaller     // Read-only binding to the contract
	OnchainTransactor // Write-only binding to the contract
	OnchainFilterer   // Log filterer for contract events
}

// OnchainCaller is an auto generated read-only Go binding around an Ethereum contract.
type OnchainCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OnchainTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OnchainFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OnchainSession struct {
	Contract     *Onchain          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OnchainCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OnchainCallerSession struct {
	Contract *OnchainCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OnchainTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OnchainTransactorSession struct {
	Contract     *OnchainTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OnchainRaw is an auto generated low-level Go binding around an Ethereum contract.
type OnchainRaw struct {
	Contract *Onchain // Generic contract binding to access the raw methods on
}

// OnchainCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OnchainCallerRaw struct {
	Contract *OnchainCaller // Generic read-only contract binding to access the raw methods on
}

// OnchainTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OnchainTransactorRaw struct {
	Contract *OnchainTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOnchain creates a new instance of Onchain, bound to a specific deployed contract.
func NewOnchain(address common.Address, backend bind.ContractBackend) (*Onchain, error) {
	contract, err := bindOnchain(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Onchain{OnchainCaller: OnchainCaller{contract: contract}, OnchainTransactor: OnchainTransactor{contract: contract}, OnchainFilterer: OnchainFilterer{contract: contract}}, nil
}

// NewOnchainCaller creates a new read-only instance of Onchain, bound to a specific deployed contract.
func NewOnchainCaller(address common.Address, caller bind.ContractCaller) (*OnchainCaller, error) {
	contract, err := bindOnchain(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainCaller{contract: contract}, nil
}

// NewOnchainTransactor creates a new write-only instance of Onchain, bound to a specific deployed contract.
func NewOnchainTransactor(address common.Address, transactor bind.ContractTransactor) (*OnchainTransactor, error) {
	contract, err := bindOnchain(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainTransactor{contract: contract}, nil
}

// NewOnchainFilterer creates a new log filterer instance of Onchain, bound to a specific deployed contract.
func NewOnchainFilterer(address common.Address, filterer bind.ContractFilterer) (*OnchainFilterer, error) {
	contract, err := bindOnchain(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OnchainFilterer{contract: contract}, nil
}

// bindOnchain binds a generic wrapper to an already deployed contract.
func bindOnchain(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OnchainMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Onchain *OnchainRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Onchain.Contract.OnchainCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Onchain *OnchainRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.Contract.OnchainTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Onchain *OnchainRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Onchain.Contract.OnchainTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Onchain *OnchainCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Onchain.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Onchain *OnchainTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Onchain *OnchainTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Onchain.Contract.contract.Transact(opts, method, params...)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainCaller) AddressToString(opts *bind.CallOpts, _addr common.Address) (string, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "addressToString", _addr)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainSession) AddressToString(_addr common.Address) (string, error) {
	return _Onchain.Contract.AddressToString(&_Onchain.CallOpts, _addr)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainCallerSession) AddressToString(_addr common.Address) (string, error) {
	return _Onchain.Contract.AddressToString(&_Onchain.CallOpts, _addr)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainCaller) GetRegisterFee(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "getRegisterFee")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainSession) GetRegisterFee() (*big.Int, error) {
	return _Onchain.Contract.GetRegisterFee(&_Onchain.CallOpts)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainCallerSession) GetRegisterFee() (*big.Int, error) {
	return _Onchain.Contract.GetRegisterFee(&_Onchain.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainCaller) GetWaitingTime(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "getWaitingTime")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainSession) GetWaitingTime() (*big.Int, error) {
	return _Onchain.Contract.GetWaitingTime(&_Onchain.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainCallerSession) GetWaitingTime() (*big.Int, error) {
	return _Onchain.Contract.GetWaitingTime(&_Onchain.CallOpts)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainCaller) IsMatcher(opts *bind.CallOpts, _m common.Address) (bool, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "isMatcher", _m)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainSession) IsMatcher(_m common.Address) (bool, error) {
	return _Onchain.Contract.IsMatcher(&_Onchain.CallOpts, _m)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainCallerSession) IsMatcher(_m common.Address) (bool, error) {
	return _Onchain.Contract.IsMatcher(&_Onchain.CallOpts, _m)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainCaller) IsPending(opts *bind.CallOpts, batchID [16]byte) (bool, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "isPending", batchID)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainSession) IsPending(batchID [16]byte) (bool, error) {
	return _Onchain.Contract.IsPending(&_Onchain.CallOpts, batchID)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainCallerSession) IsPending(batchID [16]byte) (bool, error) {
	return _Onchain.Contract.IsPending(&_Onchain.CallOpts, batchID)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainCaller) UintToString(opts *bind.CallOpts, num *big.Int) (string, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "uintToString", num)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainSession) UintToString(num *big.Int) (string, error) {
	return _Onchain.Contract.UintToString(&_Onchain.CallOpts, num)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainCallerSession) UintToString(num *big.Int) (string, error) {
	return _Onchain.Contract.UintToString(&_Onchain.CallOpts, num)
}

// Matching is a paid mutator transaction binding the contract method 0x0c145e73.
//
// Solidity: function matching(bytes16 bidBatchID, bytes16 askBatchID) returns()
func (_Onchain *OnchainTransactor) Matching(opts *bind.TransactOpts, bidBatchID [16]byte, askBatchID [16]byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "matching", bidBatchID, askBatchID)
}

// Matching is a paid mutator transaction binding the contract method 0x0c145e73.
//
// Solidity: function matching(bytes16 bidBatchID, bytes16 askBatchID) returns()
func (_Onchain *OnchainSession) Matching(bidBatchID [16]byte, askBatchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.Matching(&_Onchain.TransactOpts, bidBatchID, askBatchID)
}

// Matching is a paid mutator transaction binding the contract method 0x0c145e73.
//
// Solidity: function matching(bytes16 bidBatchID, bytes16 askBatchID) returns()
func (_Onchain *OnchainTransactorSession) Matching(bidBatchID [16]byte, askBatchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.Matching(&_Onchain.TransactOpts, bidBatchID, askBatchID)
}

// MyDeposit is a paid mutator transaction binding the contract method 0x2a096397.
//
// Solidity: function myDeposit() payable returns()
func (_Onchain *OnchainTransactor) MyDeposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "myDeposit")
}

// MyDeposit is a paid mutator transaction binding the contract method 0x2a096397.
//
// Solidity: function myDeposit() payable returns()
func (_Onchain *OnchainSession) MyDeposit() (*types.Transaction, error) {
	return _Onchain.Contract.MyDeposit(&_Onchain.TransactOpts)
}

// MyDeposit is a paid mutator transaction binding the contract method 0x2a096397.
//
// Solidity: function myDeposit() payable returns()
func (_Onchain *OnchainTransactorSession) MyDeposit() (*types.Transaction, error) {
	return _Onchain.Contract.MyDeposit(&_Onchain.TransactOpts)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainTransactor) Register(opts *bind.TransactOpts, _m common.Address) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "register", _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainSession) Register(_m common.Address) (*types.Transaction, error) {
	return _Onchain.Contract.Register(&_Onchain.TransactOpts, _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainTransactorSession) Register(_m common.Address) (*types.Transaction, error) {
	return _Onchain.Contract.Register(&_Onchain.TransactOpts, _m)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainTransactor) ReportMissingDeadline(opts *bind.TransactOpts, batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "reportMissingDeadline", batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.ReportMissingDeadline(&_Onchain.TransactOpts, batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainTransactorSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.ReportMissingDeadline(&_Onchain.TransactOpts, batchID)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainTransactor) SendBatch(opts *bind.TransactOpts, batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "sendBatch", batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.Contract.SendBatch(&_Onchain.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainTransactorSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.Contract.SendBatch(&_Onchain.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x0ffde4c5.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32,address)[] _ords) returns()
func (_Onchain *OnchainTransactor) SubmitOrderDetails(opts *bind.TransactOpts, batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "submitOrderDetails", batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x0ffde4c5.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32,address)[] _ords) returns()
func (_Onchain *OnchainSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.Contract.SubmitOrderDetails(&_Onchain.TransactOpts, batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x0ffde4c5.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32,address)[] _ords) returns()
func (_Onchain *OnchainTransactorSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.Contract.SubmitOrderDetails(&_Onchain.TransactOpts, batchID, _ords)
}

// OnchainAcceptBatchIterator is returned from FilterAcceptBatch and is used to iterate over the raw logs and unpacked data for AcceptBatch events raised by the Onchain contract.
type OnchainAcceptBatchIterator struct {
	Event *OnchainAcceptBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainAcceptBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainAcceptBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainAcceptBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainAcceptBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainAcceptBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainAcceptBatch represents a AcceptBatch event raised by the Onchain contract.
type OnchainAcceptBatch struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Arg2 *big.Int
	Arg3 bool
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAcceptBatch is a free log retrieval operation binding the contract event 0x4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd.
//
// Solidity: event AcceptBatch(bytes16 arg0, uint256 arg1, uint256 arg2, bool arg3)
func (_Onchain *OnchainFilterer) FilterAcceptBatch(opts *bind.FilterOpts) (*OnchainAcceptBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainAcceptBatchIterator{contract: _Onchain.contract, event: "AcceptBatch", logs: logs, sub: sub}, nil
}

// WatchAcceptBatch is a free log subscription operation binding the contract event 0x4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd.
//
// Solidity: event AcceptBatch(bytes16 arg0, uint256 arg1, uint256 arg2, bool arg3)
func (_Onchain *OnchainFilterer) WatchAcceptBatch(opts *bind.WatchOpts, sink chan<- *OnchainAcceptBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainAcceptBatch)
				if err := _Onchain.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAcceptBatch is a log parse operation binding the contract event 0x4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd.
//
// Solidity: event AcceptBatch(bytes16 arg0, uint256 arg1, uint256 arg2, bool arg3)
func (_Onchain *OnchainFilterer) ParseAcceptBatch(log types.Log) (*OnchainAcceptBatch, error) {
	event := new(OnchainAcceptBatch)
	if err := _Onchain.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainBatchMatchAmountAndProfitIterator is returned from FilterBatchMatchAmountAndProfit and is used to iterate over the raw logs and unpacked data for BatchMatchAmountAndProfit events raised by the Onchain contract.
type OnchainBatchMatchAmountAndProfitIterator struct {
	Event *OnchainBatchMatchAmountAndProfit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainBatchMatchAmountAndProfitIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainBatchMatchAmountAndProfit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainBatchMatchAmountAndProfit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainBatchMatchAmountAndProfitIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainBatchMatchAmountAndProfitIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainBatchMatchAmountAndProfit represents a BatchMatchAmountAndProfit event raised by the Onchain contract.
type OnchainBatchMatchAmountAndProfit struct {
	Arg0 *big.Int
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBatchMatchAmountAndProfit is a free log retrieval operation binding the contract event 0x99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c.
//
// Solidity: event BatchMatchAmountAndProfit(uint256 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterBatchMatchAmountAndProfit(opts *bind.FilterOpts) (*OnchainBatchMatchAmountAndProfitIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "BatchMatchAmountAndProfit")
	if err != nil {
		return nil, err
	}
	return &OnchainBatchMatchAmountAndProfitIterator{contract: _Onchain.contract, event: "BatchMatchAmountAndProfit", logs: logs, sub: sub}, nil
}

// WatchBatchMatchAmountAndProfit is a free log subscription operation binding the contract event 0x99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c.
//
// Solidity: event BatchMatchAmountAndProfit(uint256 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchBatchMatchAmountAndProfit(opts *bind.WatchOpts, sink chan<- *OnchainBatchMatchAmountAndProfit) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "BatchMatchAmountAndProfit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainBatchMatchAmountAndProfit)
				if err := _Onchain.contract.UnpackLog(event, "BatchMatchAmountAndProfit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchMatchAmountAndProfit is a log parse operation binding the contract event 0x99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c.
//
// Solidity: event BatchMatchAmountAndProfit(uint256 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseBatchMatchAmountAndProfit(log types.Log) (*OnchainBatchMatchAmountAndProfit, error) {
	event := new(OnchainBatchMatchAmountAndProfit)
	if err := _Onchain.contract.UnpackLog(event, "BatchMatchAmountAndProfit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainBatchRawProfitIterator is returned from FilterBatchRawProfit and is used to iterate over the raw logs and unpacked data for BatchRawProfit events raised by the Onchain contract.
type OnchainBatchRawProfitIterator struct {
	Event *OnchainBatchRawProfit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainBatchRawProfitIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainBatchRawProfit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainBatchRawProfit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainBatchRawProfitIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainBatchRawProfitIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainBatchRawProfit represents a BatchRawProfit event raised by the Onchain contract.
type OnchainBatchRawProfit struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBatchRawProfit is a free log retrieval operation binding the contract event 0xe815d3dc17143b69b6fb9905c4f0a0da9afaecfbda798ab64633b254ce53017a.
//
// Solidity: event BatchRawProfit(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterBatchRawProfit(opts *bind.FilterOpts) (*OnchainBatchRawProfitIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "BatchRawProfit")
	if err != nil {
		return nil, err
	}
	return &OnchainBatchRawProfitIterator{contract: _Onchain.contract, event: "BatchRawProfit", logs: logs, sub: sub}, nil
}

// WatchBatchRawProfit is a free log subscription operation binding the contract event 0xe815d3dc17143b69b6fb9905c4f0a0da9afaecfbda798ab64633b254ce53017a.
//
// Solidity: event BatchRawProfit(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchBatchRawProfit(opts *bind.WatchOpts, sink chan<- *OnchainBatchRawProfit) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "BatchRawProfit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainBatchRawProfit)
				if err := _Onchain.contract.UnpackLog(event, "BatchRawProfit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchRawProfit is a log parse operation binding the contract event 0xe815d3dc17143b69b6fb9905c4f0a0da9afaecfbda798ab64633b254ce53017a.
//
// Solidity: event BatchRawProfit(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseBatchRawProfit(log types.Log) (*OnchainBatchRawProfit, error) {
	event := new(OnchainBatchRawProfit)
	if err := _Onchain.contract.UnpackLog(event, "BatchRawProfit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainBatchTimestampIterator is returned from FilterBatchTimestamp and is used to iterate over the raw logs and unpacked data for BatchTimestamp events raised by the Onchain contract.
type OnchainBatchTimestampIterator struct {
	Event *OnchainBatchTimestamp // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainBatchTimestampIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainBatchTimestamp)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainBatchTimestamp)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainBatchTimestampIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainBatchTimestampIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainBatchTimestamp represents a BatchTimestamp event raised by the Onchain contract.
type OnchainBatchTimestamp struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBatchTimestamp is a free log retrieval operation binding the contract event 0x6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f668.
//
// Solidity: event BatchTimestamp(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterBatchTimestamp(opts *bind.FilterOpts) (*OnchainBatchTimestampIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "BatchTimestamp")
	if err != nil {
		return nil, err
	}
	return &OnchainBatchTimestampIterator{contract: _Onchain.contract, event: "BatchTimestamp", logs: logs, sub: sub}, nil
}

// WatchBatchTimestamp is a free log subscription operation binding the contract event 0x6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f668.
//
// Solidity: event BatchTimestamp(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchBatchTimestamp(opts *bind.WatchOpts, sink chan<- *OnchainBatchTimestamp) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "BatchTimestamp")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainBatchTimestamp)
				if err := _Onchain.contract.UnpackLog(event, "BatchTimestamp", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchTimestamp is a log parse operation binding the contract event 0x6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f668.
//
// Solidity: event BatchTimestamp(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseBatchTimestamp(log types.Log) (*OnchainBatchTimestamp, error) {
	event := new(OnchainBatchTimestamp)
	if err := _Onchain.contract.UnpackLog(event, "BatchTimestamp", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainFullfilMatchIterator is returned from FilterFullfilMatch and is used to iterate over the raw logs and unpacked data for FullfilMatch events raised by the Onchain contract.
type OnchainFullfilMatchIterator struct {
	Event *OnchainFullfilMatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainFullfilMatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainFullfilMatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainFullfilMatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainFullfilMatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainFullfilMatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainFullfilMatch represents a FullfilMatch event raised by the Onchain contract.
type OnchainFullfilMatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFullfilMatch is a free log retrieval operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterFullfilMatch(opts *bind.FilterOpts) (*OnchainFullfilMatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return &OnchainFullfilMatchIterator{contract: _Onchain.contract, event: "FullfilMatch", logs: logs, sub: sub}, nil
}

// WatchFullfilMatch is a free log subscription operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchFullfilMatch(opts *bind.WatchOpts, sink chan<- *OnchainFullfilMatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainFullfilMatch)
				if err := _Onchain.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFullfilMatch is a log parse operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseFullfilMatch(log types.Log) (*OnchainFullfilMatch, error) {
	event := new(OnchainFullfilMatch)
	if err := _Onchain.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainInvalidBatchIterator is returned from FilterInvalidBatch and is used to iterate over the raw logs and unpacked data for InvalidBatch events raised by the Onchain contract.
type OnchainInvalidBatchIterator struct {
	Event *OnchainInvalidBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainInvalidBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainInvalidBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainInvalidBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainInvalidBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainInvalidBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainInvalidBatch represents a InvalidBatch event raised by the Onchain contract.
type OnchainInvalidBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidBatch is a free log retrieval operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterInvalidBatch(opts *bind.FilterOpts) (*OnchainInvalidBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainInvalidBatchIterator{contract: _Onchain.contract, event: "InvalidBatch", logs: logs, sub: sub}, nil
}

// WatchInvalidBatch is a free log subscription operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchInvalidBatch(opts *bind.WatchOpts, sink chan<- *OnchainInvalidBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainInvalidBatch)
				if err := _Onchain.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidBatch is a log parse operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseInvalidBatch(log types.Log) (*OnchainInvalidBatch, error) {
	event := new(OnchainInvalidBatch)
	if err := _Onchain.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainInvalidOrderIterator is returned from FilterInvalidOrder and is used to iterate over the raw logs and unpacked data for InvalidOrder events raised by the Onchain contract.
type OnchainInvalidOrderIterator struct {
	Event *OnchainInvalidOrder // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainInvalidOrderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainInvalidOrder)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainInvalidOrder)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainInvalidOrderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainInvalidOrderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainInvalidOrder represents a InvalidOrder event raised by the Onchain contract.
type OnchainInvalidOrder struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidOrder is a free log retrieval operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterInvalidOrder(opts *bind.FilterOpts) (*OnchainInvalidOrderIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return &OnchainInvalidOrderIterator{contract: _Onchain.contract, event: "InvalidOrder", logs: logs, sub: sub}, nil
}

// WatchInvalidOrder is a free log subscription operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchInvalidOrder(opts *bind.WatchOpts, sink chan<- *OnchainInvalidOrder) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainInvalidOrder)
				if err := _Onchain.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidOrder is a log parse operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseInvalidOrder(log types.Log) (*OnchainInvalidOrder, error) {
	event := new(OnchainInvalidOrder)
	if err := _Onchain.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the Onchain contract.
type OnchainLogAddressIterator struct {
	Event *OnchainLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogAddress represents a LogAddress event raised by the Onchain contract.
type OnchainLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) FilterLogAddress(opts *bind.FilterOpts) (*OnchainLogAddressIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return &OnchainLogAddressIterator{contract: _Onchain.contract, event: "LogAddress", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *OnchainLogAddress) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogAddress)
				if err := _Onchain.contract.UnpackLog(event, "LogAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) ParseLogAddress(log types.Log) (*OnchainLogAddress, error) {
	event := new(OnchainLogAddress)
	if err := _Onchain.contract.UnpackLog(event, "LogAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the Onchain contract.
type OnchainLogBytesIterator struct {
	Event *OnchainLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes represents a LogBytes event raised by the Onchain contract.
type OnchainLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes(opts *bind.FilterOpts) (*OnchainLogBytesIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytesIterator{contract: _Onchain.contract, event: "LogBytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes(log types.Log) (*OnchainLogBytes, error) {
	event := new(OnchainLogBytes)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytes16Iterator is returned from FilterLogBytes16 and is used to iterate over the raw logs and unpacked data for LogBytes16 events raised by the Onchain contract.
type OnchainLogBytes16Iterator struct {
	Event *OnchainLogBytes16 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytes16Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes16)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes16)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytes16Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytes16Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes16 represents a LogBytes16 event raised by the Onchain contract.
type OnchainLogBytes16 struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes16 is a free log retrieval operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes16(opts *bind.FilterOpts) (*OnchainLogBytes16Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytes16Iterator{contract: _Onchain.contract, event: "LogBytes16", logs: logs, sub: sub}, nil
}

// WatchLogBytes16 is a free log subscription operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes16(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes16) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes16)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes16", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes16 is a log parse operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes16(log types.Log) (*OnchainLogBytes16, error) {
	event := new(OnchainLogBytes16)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes16", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the Onchain contract.
type OnchainLogBytes32Iterator struct {
	Event *OnchainLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes32 represents a LogBytes32 event raised by the Onchain contract.
type OnchainLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*OnchainLogBytes32Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytes32Iterator{contract: _Onchain.contract, event: "LogBytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes32) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes32)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes32(log types.Log) (*OnchainLogBytes32, error) {
	event := new(OnchainLogBytes32)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogRecoverErrorIterator is returned from FilterLogRecoverError and is used to iterate over the raw logs and unpacked data for LogRecoverError events raised by the Onchain contract.
type OnchainLogRecoverErrorIterator struct {
	Event *OnchainLogRecoverError // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogRecoverErrorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogRecoverError)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogRecoverError)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogRecoverErrorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogRecoverErrorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogRecoverError represents a LogRecoverError event raised by the Onchain contract.
type OnchainLogRecoverError struct {
	Arg0 uint8
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogRecoverError is a free log retrieval operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) FilterLogRecoverError(opts *bind.FilterOpts) (*OnchainLogRecoverErrorIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return &OnchainLogRecoverErrorIterator{contract: _Onchain.contract, event: "LogRecoverError", logs: logs, sub: sub}, nil
}

// WatchLogRecoverError is a free log subscription operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) WatchLogRecoverError(opts *bind.WatchOpts, sink chan<- *OnchainLogRecoverError) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogRecoverError)
				if err := _Onchain.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogRecoverError is a log parse operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) ParseLogRecoverError(log types.Log) (*OnchainLogRecoverError, error) {
	event := new(OnchainLogRecoverError)
	if err := _Onchain.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the Onchain contract.
type OnchainLogStringIterator struct {
	Event *OnchainLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogString represents a LogString event raised by the Onchain contract.
type OnchainLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) FilterLogString(opts *bind.FilterOpts) (*OnchainLogStringIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return &OnchainLogStringIterator{contract: _Onchain.contract, event: "LogString", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *OnchainLogString) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogString)
				if err := _Onchain.contract.UnpackLog(event, "LogString", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) ParseLogString(log types.Log) (*OnchainLogString, error) {
	event := new(OnchainLogString)
	if err := _Onchain.contract.UnpackLog(event, "LogString", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogUint256Iterator is returned from FilterLogUint256 and is used to iterate over the raw logs and unpacked data for LogUint256 events raised by the Onchain contract.
type OnchainLogUint256Iterator struct {
	Event *OnchainLogUint256 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogUint256Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogUint256)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogUint256)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogUint256Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogUint256Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogUint256 represents a LogUint256 event raised by the Onchain contract.
type OnchainLogUint256 struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint256 is a free log retrieval operation binding the contract event 0x535266f26566acd2ef175615d9f1140b36f149b810b33fb93143236a69912c32.
//
// Solidity: event LogUint256(uint256 arg0)
func (_Onchain *OnchainFilterer) FilterLogUint256(opts *bind.FilterOpts) (*OnchainLogUint256Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogUint256")
	if err != nil {
		return nil, err
	}
	return &OnchainLogUint256Iterator{contract: _Onchain.contract, event: "LogUint256", logs: logs, sub: sub}, nil
}

// WatchLogUint256 is a free log subscription operation binding the contract event 0x535266f26566acd2ef175615d9f1140b36f149b810b33fb93143236a69912c32.
//
// Solidity: event LogUint256(uint256 arg0)
func (_Onchain *OnchainFilterer) WatchLogUint256(opts *bind.WatchOpts, sink chan<- *OnchainLogUint256) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogUint256")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogUint256)
				if err := _Onchain.contract.UnpackLog(event, "LogUint256", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint256 is a log parse operation binding the contract event 0x535266f26566acd2ef175615d9f1140b36f149b810b33fb93143236a69912c32.
//
// Solidity: event LogUint256(uint256 arg0)
func (_Onchain *OnchainFilterer) ParseLogUint256(log types.Log) (*OnchainLogUint256, error) {
	event := new(OnchainLogUint256)
	if err := _Onchain.contract.UnpackLog(event, "LogUint256", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainMatchedPriceIterator is returned from FilterMatchedPrice and is used to iterate over the raw logs and unpacked data for MatchedPrice events raised by the Onchain contract.
type OnchainMatchedPriceIterator struct {
	Event *OnchainMatchedPrice // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainMatchedPriceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainMatchedPrice)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainMatchedPrice)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainMatchedPriceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainMatchedPriceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainMatchedPrice represents a MatchedPrice event raised by the Onchain contract.
type OnchainMatchedPrice struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterMatchedPrice is a free log retrieval operation binding the contract event 0x21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7.
//
// Solidity: event MatchedPrice(uint256 arg0)
func (_Onchain *OnchainFilterer) FilterMatchedPrice(opts *bind.FilterOpts) (*OnchainMatchedPriceIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "MatchedPrice")
	if err != nil {
		return nil, err
	}
	return &OnchainMatchedPriceIterator{contract: _Onchain.contract, event: "MatchedPrice", logs: logs, sub: sub}, nil
}

// WatchMatchedPrice is a free log subscription operation binding the contract event 0x21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7.
//
// Solidity: event MatchedPrice(uint256 arg0)
func (_Onchain *OnchainFilterer) WatchMatchedPrice(opts *bind.WatchOpts, sink chan<- *OnchainMatchedPrice) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "MatchedPrice")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainMatchedPrice)
				if err := _Onchain.contract.UnpackLog(event, "MatchedPrice", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMatchedPrice is a log parse operation binding the contract event 0x21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7.
//
// Solidity: event MatchedPrice(uint256 arg0)
func (_Onchain *OnchainFilterer) ParseMatchedPrice(log types.Log) (*OnchainMatchedPrice, error) {
	event := new(OnchainMatchedPrice)
	if err := _Onchain.contract.UnpackLog(event, "MatchedPrice", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainPunishMatcherIterator is returned from FilterPunishMatcher and is used to iterate over the raw logs and unpacked data for PunishMatcher events raised by the Onchain contract.
type OnchainPunishMatcherIterator struct {
	Event *OnchainPunishMatcher // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainPunishMatcherIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainPunishMatcher)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainPunishMatcher)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainPunishMatcherIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainPunishMatcherIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainPunishMatcher represents a PunishMatcher event raised by the Onchain contract.
type OnchainPunishMatcher struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPunishMatcher is a free log retrieval operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) FilterPunishMatcher(opts *bind.FilterOpts) (*OnchainPunishMatcherIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return &OnchainPunishMatcherIterator{contract: _Onchain.contract, event: "PunishMatcher", logs: logs, sub: sub}, nil
}

// WatchPunishMatcher is a free log subscription operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) WatchPunishMatcher(opts *bind.WatchOpts, sink chan<- *OnchainPunishMatcher) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainPunishMatcher)
				if err := _Onchain.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePunishMatcher is a log parse operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) ParsePunishMatcher(log types.Log) (*OnchainPunishMatcher, error) {
	event := new(OnchainPunishMatcher)
	if err := _Onchain.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainReceivedBatchDetailsIterator is returned from FilterReceivedBatchDetails and is used to iterate over the raw logs and unpacked data for ReceivedBatchDetails events raised by the Onchain contract.
type OnchainReceivedBatchDetailsIterator struct {
	Event *OnchainReceivedBatchDetails // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainReceivedBatchDetailsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainReceivedBatchDetails)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainReceivedBatchDetails)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainReceivedBatchDetailsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainReceivedBatchDetailsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainReceivedBatchDetails represents a ReceivedBatchDetails event raised by the Onchain contract.
type OnchainReceivedBatchDetails struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterReceivedBatchDetails is a free log retrieval operation binding the contract event 0xd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterReceivedBatchDetails(opts *bind.FilterOpts) (*OnchainReceivedBatchDetailsIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return &OnchainReceivedBatchDetailsIterator{contract: _Onchain.contract, event: "ReceivedBatchDetails", logs: logs, sub: sub}, nil
}

// WatchReceivedBatchDetails is a free log subscription operation binding the contract event 0xd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchReceivedBatchDetails(opts *bind.WatchOpts, sink chan<- *OnchainReceivedBatchDetails) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainReceivedBatchDetails)
				if err := _Onchain.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseReceivedBatchDetails is a log parse operation binding the contract event 0xd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseReceivedBatchDetails(log types.Log) (*OnchainReceivedBatchDetails, error) {
	event := new(OnchainReceivedBatchDetails)
	if err := _Onchain.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainRemoveBatchOutOfDateIterator is returned from FilterRemoveBatchOutOfDate and is used to iterate over the raw logs and unpacked data for RemoveBatchOutOfDate events raised by the Onchain contract.
type OnchainRemoveBatchOutOfDateIterator struct {
	Event *OnchainRemoveBatchOutOfDate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainRemoveBatchOutOfDateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainRemoveBatchOutOfDate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainRemoveBatchOutOfDate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainRemoveBatchOutOfDateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainRemoveBatchOutOfDateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainRemoveBatchOutOfDate represents a RemoveBatchOutOfDate event raised by the Onchain contract.
type OnchainRemoveBatchOutOfDate struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRemoveBatchOutOfDate is a free log retrieval operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterRemoveBatchOutOfDate(opts *bind.FilterOpts) (*OnchainRemoveBatchOutOfDateIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return &OnchainRemoveBatchOutOfDateIterator{contract: _Onchain.contract, event: "RemoveBatchOutOfDate", logs: logs, sub: sub}, nil
}

// WatchRemoveBatchOutOfDate is a free log subscription operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchRemoveBatchOutOfDate(opts *bind.WatchOpts, sink chan<- *OnchainRemoveBatchOutOfDate) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainRemoveBatchOutOfDate)
				if err := _Onchain.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRemoveBatchOutOfDate is a log parse operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseRemoveBatchOutOfDate(log types.Log) (*OnchainRemoveBatchOutOfDate, error) {
	event := new(OnchainRemoveBatchOutOfDate)
	if err := _Onchain.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainRevertBatchIterator is returned from FilterRevertBatch and is used to iterate over the raw logs and unpacked data for RevertBatch events raised by the Onchain contract.
type OnchainRevertBatchIterator struct {
	Event *OnchainRevertBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainRevertBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainRevertBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainRevertBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainRevertBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainRevertBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainRevertBatch represents a RevertBatch event raised by the Onchain contract.
type OnchainRevertBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRevertBatch is a free log retrieval operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterRevertBatch(opts *bind.FilterOpts) (*OnchainRevertBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainRevertBatchIterator{contract: _Onchain.contract, event: "RevertBatch", logs: logs, sub: sub}, nil
}

// WatchRevertBatch is a free log subscription operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchRevertBatch(opts *bind.WatchOpts, sink chan<- *OnchainRevertBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainRevertBatch)
				if err := _Onchain.contract.UnpackLog(event, "RevertBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRevertBatch is a log parse operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseRevertBatch(log types.Log) (*OnchainRevertBatch, error) {
	event := new(OnchainRevertBatch)
	if err := _Onchain.contract.UnpackLog(event, "RevertBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainValidMatchingIterator is returned from FilterValidMatching and is used to iterate over the raw logs and unpacked data for ValidMatching events raised by the Onchain contract.
type OnchainValidMatchingIterator struct {
	Event *OnchainValidMatching // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainValidMatchingIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainValidMatching)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainValidMatching)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainValidMatchingIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainValidMatchingIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainValidMatching represents a ValidMatching event raised by the Onchain contract.
type OnchainValidMatching struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterValidMatching is a free log retrieval operation binding the contract event 0xd34b097bfa1e657b66a63bd1147719fd1b7022724f5a33cb87e99c4764ab8c02.
//
// Solidity: event ValidMatching(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterValidMatching(opts *bind.FilterOpts) (*OnchainValidMatchingIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "ValidMatching")
	if err != nil {
		return nil, err
	}
	return &OnchainValidMatchingIterator{contract: _Onchain.contract, event: "ValidMatching", logs: logs, sub: sub}, nil
}

// WatchValidMatching is a free log subscription operation binding the contract event 0xd34b097bfa1e657b66a63bd1147719fd1b7022724f5a33cb87e99c4764ab8c02.
//
// Solidity: event ValidMatching(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchValidMatching(opts *bind.WatchOpts, sink chan<- *OnchainValidMatching) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "ValidMatching")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainValidMatching)
				if err := _Onchain.contract.UnpackLog(event, "ValidMatching", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidMatching is a log parse operation binding the contract event 0xd34b097bfa1e657b66a63bd1147719fd1b7022724f5a33cb87e99c4764ab8c02.
//
// Solidity: event ValidMatching(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseValidMatching(log types.Log) (*OnchainValidMatching, error) {
	event := new(OnchainValidMatching)
	if err := _Onchain.contract.UnpackLog(event, "ValidMatching", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
