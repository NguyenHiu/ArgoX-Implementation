// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package onchain

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// OnchainOrder is an auto generated low-level Go binding around an user-defined struct.
type OnchainOrder struct {
	Price             *big.Int
	Amount            *big.Int
	Side              bool
	From              [16]byte
	TradeHash         [32]byte
	OriginalOrderHash [32]byte
	Owner             common.Address
}

// OnchainMetaData contains all meta data concerning the Onchain contract.
var OnchainMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"StringsInsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"AcceptBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BatchMatchAmountAndProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BatchTimestamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"FullfilMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"LogBytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"LogBytes16\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"LogBytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumECDSA.RecoverError\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"LogRecoverError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LogUint256\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MatchedPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PunishMatcher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ReceivedBatchDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RemoveBatchOutOfDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RevertBatch\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"isMatcher\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"isPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"bidBatchID\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"askBatchID\",\"type\":\"bytes16\"}],\"name\":\"matching\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"reportMissingDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sign\",\"type\":\"bytes\"}],\"name\":\"sendBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"bytes16\",\"name\":\"from\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"originalOrderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"structOnchain.Order[]\",\"name\":\"_ords\",\"type\":\"tuple[]\"}],\"name\":\"submitOrderDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"uintToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x608060405234801562000010575f80fd5b50604051620043c8380380620043c8833981810160405281019062000036919062000138565b8060075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550670de0b6b3a76400005f81905550600a6001819055503360085f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505062000168565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6200010282620000d7565b9050919050565b6200011481620000f6565b81146200011f575f80fd5b50565b5f81519050620001328162000109565b92915050565b5f6020828403121562000150576200014f620000d3565b5b5f6200015f8482850162000122565b91505092915050565b61425280620001765f395ff3fe6080604052600436106100a6575f3560e01c806336ee67491161006357806336ee6749146101925780634420e486146101ce5780634dcbd09b146101ea5780635e57966d1461021457806378b32cf514610250578063e939567914610278576100a6565b80630c145e73146100aa5780630ffde4c5146100d257806319f5e9fe146100fa5780632a096397146101365780633005d34c1461014057806332a58e7914610168575b5f80fd5b3480156100b5575f80fd5b506100d060048036038101906100cb9190612f4d565b6102b4565b005b3480156100dd575f80fd5b506100f860048036038101906100f39190613285565b610b72565b005b348015610105575f80fd5b50610120600480360381019061011b91906132df565b611dfc565b60405161012d9190613319565b60405180910390f35b61013e611e94565b005b34801561014b575f80fd5b50610166600480360381019061016191906133e2565b611ed8565b005b348015610173575f80fd5b5061017c611fc1565b6040516101899190613496565b60405180910390f35b34801561019d575f80fd5b506101b860048036038101906101b391906134af565b611fc9565b6040516101c59190613319565b60405180910390f35b6101e860048036038101906101e391906134af565b612012565b005b3480156101f5575f80fd5b506101fe61209c565b60405161020b9190613496565b60405180910390f35b34801561021f575f80fd5b5061023a600480360381019061023591906134af565b6120a5565b6040516102479190613554565b60405180910390f35b34801561025b575f80fd5b50610276600480360381019061027191906132df565b6120cf565b005b348015610283575f80fd5b5061029e60048036038101906102999190613574565b612422565b6040516102ab9190613554565b60405180910390f35b815f73ffffffffffffffffffffffffffffffffffffffff1660035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361037d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610374906135e9565b60405180910390fd5b815f73ffffffffffffffffffffffffffffffffffffffff1660035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610446576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161043d906135e9565b60405180910390fd5b5f60035f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160048201805461055890613634565b80601f016020809104026020016040519081016040528092919081815260200182805461058490613634565b80156105cf5780601f106105a6576101008083540402835291602001916105cf565b820191905f5260205f20905b8154815290600101906020018083116105b257829003601f168201915b5050505050815260200160058201548152505090505f60035f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016004820180546106f690613634565b80601f016020809104026020016040519081016040528092919081815260200182805461072290613634565b801561076d5780601f106107445761010080835404028352916020019161076d565b820191905f5260205f20905b81548152906001019060200180831161075057829003601f168201915b505050505081526020016005820154815250509050856fffffffffffffffffffffffffffffffff1916825f01516fffffffffffffffffffffffffffffffff1916146107ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107e4906136ae565b60405180910390fd5b5f8260c0015114610833576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082a90613716565b60405180910390fd5b846fffffffffffffffffffffffffffffffff1916815f01516fffffffffffffffffffffffffffffffff19161461089e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108959061377e565b60405180910390fd5b5f8160c00151146108e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108db906137e6565b60405180910390fd5b8060200151826020015110158015610903575080604001518260400151145b15610b6a575f60028260200151846020015161091f9190613831565b6109299190613891565b90507f99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c836040015182856020015161096191906138c1565b60405161096f9291906138f4565b60405180910390a17f21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7816040516109a69190613496565b60405180910390a14260035f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055504260035f886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050181905550815f015160045f855f01516fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c0217905550825f015160045f845f01516fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055507f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965835f0151604051610b26919061392a565b60405180910390a17f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965825f0151604051610b60919061392a565b60405180910390a1505b505050505050565b815f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015403610bef576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610be69061398d565b60405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610cb8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610caf906139f5565b60405180910390fd5b7f6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f6688442604051610ce9929190613a13565b60405180910390a15f60605f5b85518160ff161015610e5d57858160ff1681518110610d1857610d17613a3a565b5b60200260200101516020015183610d2f9190613831565b925081868260ff1681518110610d4857610d47613a3a565b5b60200260200101515f0151878360ff1681518110610d6957610d68613a3a565b5b602002602001015160200151888460ff1681518110610d8b57610d8a613a3a565b5b602002602001015160400151898560ff1681518110610dad57610dac613a3a565b5b602002602001015160600151604051602001610dcc9493929190613aec565b60405160208183030381529060405280519060200120878360ff1681518110610df857610df7613a3a565b5b602002602001015160800151888460ff1681518110610e1a57610e19613a3a565b5b602002602001015160a00151604051602001610e399493929190613b9d565b60405160208183030381529060405291508080610e5590613bf2565b915050610cf6565b5060035f876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600201548214610edd577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad74886604051610ece919061392a565b60405180910390a15050611df6565b5f6110ef8760035f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206001015460035f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002015460035f8c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff168a518760035f8f6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516020016110139796959493929190613c76565b6040516020818303038152906040528051906020012060035f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600401805461106e90613634565b80601f016020809104026020016040519081016040528092919081815260200182805461109a90613634565b80156110e55780601f106110bc576101008083540402835291602001916110e5565b820191905f5260205f20905b8154815290600101906020018083116110c857829003601f168201915b5050505050612434565b905060035f886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146111bd577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748876040516111ad919061392a565b60405180910390a1505050611df6565b5f60065f60045f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20805490500361141a575f5b86518160ff161015611414575f604051806080016040528060035f8c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600101548152602001898460ff16815181106112b1576112b0613a3a565b5b6020026020010151602001518152602001898460ff16815181106112d8576112d7613a3a565b5b60200260200101516040015115158152602001898460ff168151811061130157611300613a3a565b5b602002602001015160c0015173ffffffffffffffffffffffffffffffffffffffff16815250905060065f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2081908060018154018082558091505060019003905f5260205f2090600302015f909190919091505f820151815f0155602082015181600101556040820151816002015f6101000a81548160ff02191690831515021790555060608201518160020160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050808061140c90613bf2565b915050611243565b50611d79565b5f60065f60045f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20805480602002602001604051908101604052809291908181526020015f905b82821015611567578382905f5260205f2090600302016040518060800160405290815f820154815260200160018201548152602001600282015f9054906101000a900460ff161515151581526020016002820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050815260200190600101906114b4565b5050505090505f815111801561159f575060011515815f8151811061158f5761158e613a3a565b5b6020026020010151604001511515145b1561178d575f5b81518160ff16101561178757818160ff16815181106115c8576115c7613a3a565b5b602002602001015160200151828260ff16815181106115ea576115e9613a3a565b5b60200260200101515f01516115ff9190613cf2565b60055f848460ff168151811061161857611617613a3a565b5b60200260200101516060015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825461166b91906138c1565b9250508190555060075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd60085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16848460ff16815181106116e7576116e6613a3a565b5b602002602001015160600151858560ff168151811061170957611708613a3a565b5b6020026020010151602001516040518463ffffffff1660e01b815260040161173393929190613d42565b6020604051808303815f875af115801561174f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117739190613d8b565b50808061177f90613bf2565b9150506115a6565b50611972565b5f5b81518160ff1610156119705760075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd838360ff16815181106117ee576117ed613a3a565b5b60200260200101516060015160085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16858560ff168151811061183257611831613a3a565b5b6020026020010151602001516040518463ffffffff1660e01b815260040161185c93929190613d42565b6020604051808303815f875af1158015611878573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061189c9190613d8b565b50818160ff16815181106118b3576118b2613a3a565b5b602002602001015160200151828260ff16815181106118d5576118d4613a3a565b5b60200260200101515f01516118ea9190613cf2565b60055f848460ff168151811061190357611902613a3a565b5b60200260200101516060015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8282546119569190613831565b92505081905550808061196890613bf2565b91505061178f565b505b5f87511180156119a4575060011515875f8151811061199457611993613a3a565b5b6020026020010151604001511515145b15611b92575f5b87518160ff161015611b8c57878160ff16815181106119cd576119cc613a3a565b5b602002602001015160200151888260ff16815181106119ef576119ee613a3a565b5b60200260200101515f0151611a049190613cf2565b60055f8a8460ff1681518110611a1d57611a1c613a3a565b5b602002602001015160c0015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254611a7091906138c1565b9250508190555060075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd60085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff168a8460ff1681518110611aec57611aeb613a3a565b5b602002602001015160c001518b8560ff1681518110611b0e57611b0d613a3a565b5b6020026020010151602001516040518463ffffffff1660e01b8152600401611b3893929190613d42565b6020604051808303815f875af1158015611b54573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b789190613d8b565b508080611b8490613bf2565b9150506119ab565b50611d77565b5f5b87518160ff161015611d755760075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd898360ff1681518110611bf357611bf2613a3a565b5b602002602001015160c0015160085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff168b8560ff1681518110611c3757611c36613a3a565b5b6020026020010151602001516040518463ffffffff1660e01b8152600401611c6193929190613d42565b6020604051808303815f875af1158015611c7d573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611ca19190613d8b565b50878160ff1681518110611cb857611cb7613a3a565b5b602002602001015160200151888260ff1681518110611cda57611cd9613a3a565b5b60200260200101515f0151611cef9190613cf2565b60055f8a8460ff1681518110611d0857611d07613a3a565b5b602002602001015160c0015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f828254611d5b9190613831565b925050819055508080611d6d90613bf2565b915050611b94565b505b505b5f60035f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055507fd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b878751604051611dea929190613a13565b60405180910390a15050505b50505050565b5f8060035f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015414158015611e8d57504260015460035f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154611e8b9190613831565b105b9050919050565b3460055f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550565b7f6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f6688642604051611f09929190613a13565b60405180910390a17f4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd86868686604051611f469493929190613db6565b60405180910390a15f6040518060e00160405280886fffffffffffffffffffffffffffffffff1916815260200187815260200186815260200185151581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018381526020015f8152509050611fb88161245e565b50505050505050565b5f8054905090565b5f8060025f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205414159050919050565b5f54341015612056576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161204d90613e43565b60405180910390fd5b5f5460025f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208190555050565b5f600154905090565b60606120c88273ffffffffffffffffffffffffffffffffffffffff166014612566565b9050919050565b805f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501540361214c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016121439061398d565b60405180910390fd5b4260015460035f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501546121959190613831565b106121d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016121cc90613eab565b60405180910390fd5b5f60025f60035f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055505f60035f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055505f60045f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b905060045f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154906fffffffffffffffffffffffffffffffff0219169055612355816127a4565b7fef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b66022083604051612384919061392a565b60405180910390a17f5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba2360035f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516124159190613ec9565b60405180910390a1505050565b606061242d82612a2e565b9050919050565b5f805f806124428686612af8565b9250925092506124528282612b4d565b82935050505092915050565b8060035f835f01516fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f820151815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555060208201518160010155604082015181600201556060820151816003015f6101000a81548160ff02191690831515021790555060808201518160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060a0820151816004019081612555919061407f565b5060c0820151816005015590505050565b60605f8390505f600284600261257c9190613cf2565b6125869190613831565b67ffffffffffffffff81111561259f5761259e612f9f565b5b6040519080825280601f01601f1916602001820160405280156125d15781602001600182028036833780820191505090505b5090507f3000000000000000000000000000000000000000000000000000000000000000815f8151811061260857612607613a3a565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053507f78000000000000000000000000000000000000000000000000000000000000008160018151811061266b5761266a613a3a565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505f60018560026126a99190613cf2565b6126b39190613831565b90505b6001811115612752577f3031323334353637383961626364656600000000000000000000000000000000600f8416601081106126f5576126f4613a3a565b5b1a60f81b82828151811061270c5761270b613a3a565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600483901c92508061274b9061414e565b90506126b6565b505f82146127995784846040517fe22e27eb0000000000000000000000000000000000000000000000000000000081526004016127909291906138f4565b60405180910390fd5b809250505092915050565b5f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015414801561284657505f60801b60045f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff191614155b15612a2b577ff335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd68160405161287a919061392a565b60405180910390a15f60035f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160048201805461299490613634565b80601f01602080910402602001604051908101604052809291908181526020018280546129c090613634565b8015612a0b5780601f106129e257610100808354040283529160200191612a0b565b820191905f5260205f20905b8154815290600101906020018083116129ee57829003601f168201915b505050505081526020016005820154815250509050612a298161245e565b505b50565b60605f6001612a3c84612caf565b0190505f8167ffffffffffffffff811115612a5a57612a59612f9f565b5b6040519080825280601f01601f191660200182016040528015612a8c5781602001600182028036833780820191505090505b5090505f82602001820190505b600115612aed578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612ae257612ae1613864565b5b0494505f8503612a99575b819350505050919050565b5f805f6041845103612b38575f805f602087015192506040870151915060608701515f1a9050612b2a88828585612e00565b955095509550505050612b46565b5f600285515f1b9250925092505b9250925092565b5f6003811115612b6057612b5f614175565b5b826003811115612b7357612b72614175565b5b0315612cab5760016003811115612b8d57612b8c614175565b5b826003811115612ba057612b9f614175565b5b03612bd7576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115612beb57612bea614175565b5b826003811115612bfe57612bfd614175565b5b03612c4257805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401612c399190613496565b60405180910390fd5b600380811115612c5557612c54614175565b5b826003811115612c6857612c67614175565b5b03612caa57806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401612ca191906141b1565b60405180910390fd5b5b5050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612d0b577a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008381612d0157612d00613864565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310612d48576d04ee2d6d415b85acef81000000008381612d3e57612d3d613864565b5b0492506020810190505b662386f26fc100008310612d7757662386f26fc100008381612d6d57612d6c613864565b5b0492506010810190505b6305f5e1008310612da0576305f5e1008381612d9657612d95613864565b5b0492506008810190505b6127108310612dc5576127108381612dbb57612dba613864565b5b0492506004810190505b60648310612de85760648381612dde57612ddd613864565b5b0492506002810190505b600a8310612df7576001810190505b80915050919050565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115612e3c575f600385925092509250612edd565b5f6001888888886040515f8152602001604052604051612e5f94939291906141d9565b6020604051602081039080840390855afa158015612e7f573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612ed0575f60015f801b93509350935050612edd565b805f805f1b935093509350505b9450945094915050565b5f604051905090565b5f80fd5b5f80fd5b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b612f2c81612ef8565b8114612f36575f80fd5b50565b5f81359050612f4781612f23565b92915050565b5f8060408385031215612f6357612f62612ef0565b5b5f612f7085828601612f39565b9250506020612f8185828601612f39565b9150509250929050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612fd582612f8f565b810181811067ffffffffffffffff82111715612ff457612ff3612f9f565b5b80604052505050565b5f613006612ee7565b90506130128282612fcc565b919050565b5f67ffffffffffffffff82111561303157613030612f9f565b5b602082029050602081019050919050565b5f80fd5b5f80fd5b5f819050919050565b61305c8161304a565b8114613066575f80fd5b50565b5f8135905061307781613053565b92915050565b5f8115159050919050565b6130918161307d565b811461309b575f80fd5b50565b5f813590506130ac81613088565b92915050565b5f819050919050565b6130c4816130b2565b81146130ce575f80fd5b50565b5f813590506130df816130bb565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61310e826130e5565b9050919050565b61311e81613104565b8114613128575f80fd5b50565b5f8135905061313981613115565b92915050565b5f60e0828403121561315457613153613046565b5b61315e60e0612ffd565b90505f61316d84828501613069565b5f83015250602061318084828501613069565b60208301525060406131948482850161309e565b60408301525060606131a884828501612f39565b60608301525060806131bc848285016130d1565b60808301525060a06131d0848285016130d1565b60a08301525060c06131e48482850161312b565b60c08301525092915050565b5f6132026131fd84613017565b612ffd565b90508083825260208201905060e0840283018581111561322557613224613042565b5b835b8181101561324e578061323a888261313f565b84526020840193505060e081019050613227565b5050509392505050565b5f82601f83011261326c5761326b612f8b565b5b813561327c8482602086016131f0565b91505092915050565b5f806040838503121561329b5761329a612ef0565b5b5f6132a885828601612f39565b925050602083013567ffffffffffffffff8111156132c9576132c8612ef4565b5b6132d585828601613258565b9150509250929050565b5f602082840312156132f4576132f3612ef0565b5b5f61330184828501612f39565b91505092915050565b6133138161307d565b82525050565b5f60208201905061332c5f83018461330a565b92915050565b5f80fd5b5f67ffffffffffffffff8211156133505761334f612f9f565b5b61335982612f8f565b9050602081019050919050565b828183375f83830152505050565b5f61338661338184613336565b612ffd565b9050828152602081018484840111156133a2576133a1613332565b5b6133ad848285613366565b509392505050565b5f82601f8301126133c9576133c8612f8b565b5b81356133d9848260208601613374565b91505092915050565b5f805f805f8060c087890312156133fc576133fb612ef0565b5b5f61340989828a01612f39565b965050602061341a89828a01613069565b955050604061342b89828a01613069565b945050606061343c89828a0161309e565b935050608061344d89828a0161312b565b92505060a087013567ffffffffffffffff81111561346e5761346d612ef4565b5b61347a89828a016133b5565b9150509295509295509295565b6134908161304a565b82525050565b5f6020820190506134a95f830184613487565b92915050565b5f602082840312156134c4576134c3612ef0565b5b5f6134d18482850161312b565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156135115780820151818401526020810190506134f6565b5f8484015250505050565b5f613526826134da565b61353081856134e4565b93506135408185602086016134f4565b61354981612f8f565b840191505092915050565b5f6020820190508181035f83015261356c818461351c565b905092915050565b5f6020828403121561358957613588612ef0565b5b5f61359684828501613069565b91505092915050565b7f74686520626174636820646f6573206e6f7420657869737400000000000000005f82015250565b5f6135d36018836134e4565b91506135de8261359f565b602082019050919050565b5f6020820190508181035f830152613600816135c7565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061364b57607f821691505b60208210810361365e5761365d613607565b5b50919050565b7f62696420626174636820646f65736e27742065787369740000000000000000005f82015250565b5f6136986017836134e4565b91506136a382613664565b602082019050919050565b5f6020820190508181035f8301526136c58161368c565b9050919050565b7f6269642062617463682069732070656e64696e670000000000000000000000005f82015250565b5f6137006014836134e4565b915061370b826136cc565b602082019050919050565b5f6020820190508181035f83015261372d816136f4565b9050919050565b7f61736b206261746368206f6465736e27742065787369740000000000000000005f82015250565b5f6137686017836134e4565b915061377382613734565b602082019050919050565b5f6020820190508181035f8301526137958161375c565b9050919050565b7f61736b2062617463682069732070656e64696e670000000000000000000000005f82015250565b5f6137d06014836134e4565b91506137db8261379c565b602082019050919050565b5f6020820190508181035f8301526137fd816137c4565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61383b8261304a565b91506138468361304a565b925082820190508082111561385e5761385d613804565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f61389b8261304a565b91506138a68361304a565b9250826138b6576138b5613864565b5b828204905092915050565b5f6138cb8261304a565b91506138d68361304a565b92508282039050818111156138ee576138ed613804565b5b92915050565b5f6040820190506139075f830185613487565b6139146020830184613487565b9392505050565b61392481612ef8565b82525050565b5f60208201905061393d5f83018461391b565b92915050565b7f746865206261746368206973206e6f742070656e64696e6700000000000000005f82015250565b5f6139776018836134e4565b915061398282613943565b602082019050919050565b5f6020820190508181035f8301526139a48161396b565b9050919050565b7f726571756972652062617463682773206f0000000000000000000000000000005f82015250565b5f6139df6011836134e4565b91506139ea826139ab565b602082019050919050565b5f6020820190508181035f830152613a0c816139d3565b9050919050565b5f604082019050613a265f83018561391b565b613a336020830184613487565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f819050919050565b613a81613a7c8261304a565b613a67565b82525050565b5f8160f81b9050919050565b5f613a9d82613a87565b9050919050565b5f613aae82613a93565b9050919050565b613ac6613ac18261307d565b613aa4565b82525050565b5f819050919050565b613ae6613ae182612ef8565b613acc565b82525050565b5f613af78287613a70565b602082019150613b078286613a70565b602082019150613b178285613ab5565b600182019150613b278284613ad5565b60108201915081905095945050505050565b5f81519050919050565b5f81905092915050565b5f613b5782613b39565b613b618185613b43565b9350613b718185602086016134f4565b80840191505092915050565b5f819050919050565b613b97613b92826130b2565b613b7d565b82525050565b5f613ba88287613b4d565b9150613bb48286613b86565b602082019150613bc48285613b86565b602082019150613bd48284613b86565b60208201915081905095945050505050565b5f60ff82169050919050565b5f613bfc82613be6565b915060ff8203613c0f57613c0e613804565b5b600182019050919050565b613c2b613c2682613be6565b613a93565b82525050565b5f8160601b9050919050565b5f613c4782613c31565b9050919050565b5f613c5882613c3d565b9050919050565b613c70613c6b82613104565b613c4e565b82525050565b5f613c81828a613ad5565b601082019150613c918289613a70565b602082019150613ca18288613a70565b602082019150613cb18287613ab5565b600182019150613cc18286613c1a565b600182019150613cd18285613b4d565b9150613cdd8284613c5f565b60148201915081905098975050505050505050565b5f613cfc8261304a565b9150613d078361304a565b9250828202613d158161304a565b91508282048414831517613d2c57613d2b613804565b5b5092915050565b613d3c81613104565b82525050565b5f606082019050613d555f830186613d33565b613d626020830185613d33565b613d6f6040830184613487565b949350505050565b5f81519050613d8581613088565b92915050565b5f60208284031215613da057613d9f612ef0565b5b5f613dad84828501613d77565b91505092915050565b5f608082019050613dc95f83018761391b565b613dd66020830186613487565b613de36040830185613487565b613df0606083018461330a565b95945050505050565b7f726567697374657220666565206973206e6f7420656e6f7567680000000000005f82015250565b5f613e2d601a836134e4565b9150613e3882613df9565b602082019050919050565b5f6020820190508181035f830152613e5a81613e21565b9050919050565b7f746865206261746368206973206e6f74206f75742d6f662d64617465000000005f82015250565b5f613e95601c836134e4565b9150613ea082613e61565b602082019050919050565b5f6020820190508181035f830152613ec281613e89565b9050919050565b5f602082019050613edc5f830184613d33565b92915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f60088302613f3e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613f03565b613f488683613f03565b95508019841693508086168417925050509392505050565b5f819050919050565b5f613f83613f7e613f798461304a565b613f60565b61304a565b9050919050565b5f819050919050565b613f9c83613f69565b613fb0613fa882613f8a565b848454613f0f565b825550505050565b5f90565b613fc4613fb8565b613fcf818484613f93565b505050565b5b81811015613ff257613fe75f82613fbc565b600181019050613fd5565b5050565b601f8211156140375761400881613ee2565b61401184613ef4565b81016020851015614020578190505b61403461402c85613ef4565b830182613fd4565b50505b505050565b5f82821c905092915050565b5f6140575f198460080261403c565b1980831691505092915050565b5f61406f8383614048565b9150826002028217905092915050565b61408882613b39565b67ffffffffffffffff8111156140a1576140a0612f9f565b5b6140ab8254613634565b6140b6828285613ff6565b5f60209050601f8311600181146140e7575f84156140d5578287015190505b6140df8582614064565b865550614146565b601f1984166140f586613ee2565b5f5b8281101561411c578489015182556001820191506020850194506020810190506140f7565b868310156141395784890151614135601f891682614048565b8355505b6001600288020188555050505b505050505050565b5f6141588261304a565b91505f820361416a57614169613804565b5b600182039050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b6141ab816130b2565b82525050565b5f6020820190506141c45f8301846141a2565b92915050565b6141d381613be6565b82525050565b5f6080820190506141ec5f8301876141a2565b6141f960208301866141ca565b61420660408301856141a2565b61421360608301846141a2565b9594505050505056fea2646970667358221220e151daee46b9428d45b46ba79b1ea951c963dbe3d88d13ea704de92e3694629764736f6c63430008180033",
}

// OnchainABI is the input ABI used to generate the binding from.
// Deprecated: Use OnchainMetaData.ABI instead.
var OnchainABI = OnchainMetaData.ABI

// OnchainBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OnchainMetaData.Bin instead.
var OnchainBin = OnchainMetaData.Bin

// DeployOnchain deploys a new Ethereum contract, binding an instance of Onchain to it.
func DeployOnchain(auth *bind.TransactOpts, backend bind.ContractBackend, _token common.Address) (common.Address, *types.Transaction, *Onchain, error) {
	parsed, err := OnchainMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OnchainBin), backend, _token)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Onchain{OnchainCaller: OnchainCaller{contract: contract}, OnchainTransactor: OnchainTransactor{contract: contract}, OnchainFilterer: OnchainFilterer{contract: contract}}, nil
}

// Onchain is an auto generated Go binding around an Ethereum contract.
type Onchain struct {
	OnchainCaller     // Read-only binding to the contract
	OnchainTransactor // Write-only binding to the contract
	OnchainFilterer   // Log filterer for contract events
}

// OnchainCaller is an auto generated read-only Go binding around an Ethereum contract.
type OnchainCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OnchainTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OnchainFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OnchainSession struct {
	Contract     *Onchain          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OnchainCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OnchainCallerSession struct {
	Contract *OnchainCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OnchainTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OnchainTransactorSession struct {
	Contract     *OnchainTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OnchainRaw is an auto generated low-level Go binding around an Ethereum contract.
type OnchainRaw struct {
	Contract *Onchain // Generic contract binding to access the raw methods on
}

// OnchainCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OnchainCallerRaw struct {
	Contract *OnchainCaller // Generic read-only contract binding to access the raw methods on
}

// OnchainTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OnchainTransactorRaw struct {
	Contract *OnchainTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOnchain creates a new instance of Onchain, bound to a specific deployed contract.
func NewOnchain(address common.Address, backend bind.ContractBackend) (*Onchain, error) {
	contract, err := bindOnchain(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Onchain{OnchainCaller: OnchainCaller{contract: contract}, OnchainTransactor: OnchainTransactor{contract: contract}, OnchainFilterer: OnchainFilterer{contract: contract}}, nil
}

// NewOnchainCaller creates a new read-only instance of Onchain, bound to a specific deployed contract.
func NewOnchainCaller(address common.Address, caller bind.ContractCaller) (*OnchainCaller, error) {
	contract, err := bindOnchain(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainCaller{contract: contract}, nil
}

// NewOnchainTransactor creates a new write-only instance of Onchain, bound to a specific deployed contract.
func NewOnchainTransactor(address common.Address, transactor bind.ContractTransactor) (*OnchainTransactor, error) {
	contract, err := bindOnchain(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainTransactor{contract: contract}, nil
}

// NewOnchainFilterer creates a new log filterer instance of Onchain, bound to a specific deployed contract.
func NewOnchainFilterer(address common.Address, filterer bind.ContractFilterer) (*OnchainFilterer, error) {
	contract, err := bindOnchain(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OnchainFilterer{contract: contract}, nil
}

// bindOnchain binds a generic wrapper to an already deployed contract.
func bindOnchain(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OnchainMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Onchain *OnchainRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Onchain.Contract.OnchainCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Onchain *OnchainRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.Contract.OnchainTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Onchain *OnchainRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Onchain.Contract.OnchainTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Onchain *OnchainCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Onchain.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Onchain *OnchainTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Onchain *OnchainTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Onchain.Contract.contract.Transact(opts, method, params...)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainCaller) AddressToString(opts *bind.CallOpts, _addr common.Address) (string, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "addressToString", _addr)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainSession) AddressToString(_addr common.Address) (string, error) {
	return _Onchain.Contract.AddressToString(&_Onchain.CallOpts, _addr)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_Onchain *OnchainCallerSession) AddressToString(_addr common.Address) (string, error) {
	return _Onchain.Contract.AddressToString(&_Onchain.CallOpts, _addr)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainCaller) GetRegisterFee(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "getRegisterFee")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainSession) GetRegisterFee() (*big.Int, error) {
	return _Onchain.Contract.GetRegisterFee(&_Onchain.CallOpts)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_Onchain *OnchainCallerSession) GetRegisterFee() (*big.Int, error) {
	return _Onchain.Contract.GetRegisterFee(&_Onchain.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainCaller) GetWaitingTime(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "getWaitingTime")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainSession) GetWaitingTime() (*big.Int, error) {
	return _Onchain.Contract.GetWaitingTime(&_Onchain.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_Onchain *OnchainCallerSession) GetWaitingTime() (*big.Int, error) {
	return _Onchain.Contract.GetWaitingTime(&_Onchain.CallOpts)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainCaller) IsMatcher(opts *bind.CallOpts, _m common.Address) (bool, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "isMatcher", _m)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainSession) IsMatcher(_m common.Address) (bool, error) {
	return _Onchain.Contract.IsMatcher(&_Onchain.CallOpts, _m)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_Onchain *OnchainCallerSession) IsMatcher(_m common.Address) (bool, error) {
	return _Onchain.Contract.IsMatcher(&_Onchain.CallOpts, _m)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainCaller) IsPending(opts *bind.CallOpts, batchID [16]byte) (bool, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "isPending", batchID)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainSession) IsPending(batchID [16]byte) (bool, error) {
	return _Onchain.Contract.IsPending(&_Onchain.CallOpts, batchID)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_Onchain *OnchainCallerSession) IsPending(batchID [16]byte) (bool, error) {
	return _Onchain.Contract.IsPending(&_Onchain.CallOpts, batchID)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainCaller) UintToString(opts *bind.CallOpts, num *big.Int) (string, error) {
	var out []interface{}
	err := _Onchain.contract.Call(opts, &out, "uintToString", num)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainSession) UintToString(num *big.Int) (string, error) {
	return _Onchain.Contract.UintToString(&_Onchain.CallOpts, num)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_Onchain *OnchainCallerSession) UintToString(num *big.Int) (string, error) {
	return _Onchain.Contract.UintToString(&_Onchain.CallOpts, num)
}

// Matching is a paid mutator transaction binding the contract method 0x0c145e73.
//
// Solidity: function matching(bytes16 bidBatchID, bytes16 askBatchID) returns()
func (_Onchain *OnchainTransactor) Matching(opts *bind.TransactOpts, bidBatchID [16]byte, askBatchID [16]byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "matching", bidBatchID, askBatchID)
}

// Matching is a paid mutator transaction binding the contract method 0x0c145e73.
//
// Solidity: function matching(bytes16 bidBatchID, bytes16 askBatchID) returns()
func (_Onchain *OnchainSession) Matching(bidBatchID [16]byte, askBatchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.Matching(&_Onchain.TransactOpts, bidBatchID, askBatchID)
}

// Matching is a paid mutator transaction binding the contract method 0x0c145e73.
//
// Solidity: function matching(bytes16 bidBatchID, bytes16 askBatchID) returns()
func (_Onchain *OnchainTransactorSession) Matching(bidBatchID [16]byte, askBatchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.Matching(&_Onchain.TransactOpts, bidBatchID, askBatchID)
}

// MyDeposit is a paid mutator transaction binding the contract method 0x2a096397.
//
// Solidity: function myDeposit() payable returns()
func (_Onchain *OnchainTransactor) MyDeposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "myDeposit")
}

// MyDeposit is a paid mutator transaction binding the contract method 0x2a096397.
//
// Solidity: function myDeposit() payable returns()
func (_Onchain *OnchainSession) MyDeposit() (*types.Transaction, error) {
	return _Onchain.Contract.MyDeposit(&_Onchain.TransactOpts)
}

// MyDeposit is a paid mutator transaction binding the contract method 0x2a096397.
//
// Solidity: function myDeposit() payable returns()
func (_Onchain *OnchainTransactorSession) MyDeposit() (*types.Transaction, error) {
	return _Onchain.Contract.MyDeposit(&_Onchain.TransactOpts)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainTransactor) Register(opts *bind.TransactOpts, _m common.Address) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "register", _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainSession) Register(_m common.Address) (*types.Transaction, error) {
	return _Onchain.Contract.Register(&_Onchain.TransactOpts, _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_Onchain *OnchainTransactorSession) Register(_m common.Address) (*types.Transaction, error) {
	return _Onchain.Contract.Register(&_Onchain.TransactOpts, _m)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainTransactor) ReportMissingDeadline(opts *bind.TransactOpts, batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "reportMissingDeadline", batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.ReportMissingDeadline(&_Onchain.TransactOpts, batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_Onchain *OnchainTransactorSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _Onchain.Contract.ReportMissingDeadline(&_Onchain.TransactOpts, batchID)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainTransactor) SendBatch(opts *bind.TransactOpts, batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "sendBatch", batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.Contract.SendBatch(&_Onchain.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_Onchain *OnchainTransactorSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _Onchain.Contract.SendBatch(&_Onchain.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x0ffde4c5.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32,address)[] _ords) returns()
func (_Onchain *OnchainTransactor) SubmitOrderDetails(opts *bind.TransactOpts, batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.contract.Transact(opts, "submitOrderDetails", batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x0ffde4c5.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32,address)[] _ords) returns()
func (_Onchain *OnchainSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.Contract.SubmitOrderDetails(&_Onchain.TransactOpts, batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x0ffde4c5.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32,address)[] _ords) returns()
func (_Onchain *OnchainTransactorSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainOrder) (*types.Transaction, error) {
	return _Onchain.Contract.SubmitOrderDetails(&_Onchain.TransactOpts, batchID, _ords)
}

// OnchainAcceptBatchIterator is returned from FilterAcceptBatch and is used to iterate over the raw logs and unpacked data for AcceptBatch events raised by the Onchain contract.
type OnchainAcceptBatchIterator struct {
	Event *OnchainAcceptBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainAcceptBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainAcceptBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainAcceptBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainAcceptBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainAcceptBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainAcceptBatch represents a AcceptBatch event raised by the Onchain contract.
type OnchainAcceptBatch struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Arg2 *big.Int
	Arg3 bool
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAcceptBatch is a free log retrieval operation binding the contract event 0x4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd.
//
// Solidity: event AcceptBatch(bytes16 arg0, uint256 arg1, uint256 arg2, bool arg3)
func (_Onchain *OnchainFilterer) FilterAcceptBatch(opts *bind.FilterOpts) (*OnchainAcceptBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainAcceptBatchIterator{contract: _Onchain.contract, event: "AcceptBatch", logs: logs, sub: sub}, nil
}

// WatchAcceptBatch is a free log subscription operation binding the contract event 0x4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd.
//
// Solidity: event AcceptBatch(bytes16 arg0, uint256 arg1, uint256 arg2, bool arg3)
func (_Onchain *OnchainFilterer) WatchAcceptBatch(opts *bind.WatchOpts, sink chan<- *OnchainAcceptBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainAcceptBatch)
				if err := _Onchain.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAcceptBatch is a log parse operation binding the contract event 0x4e69af47be64b65d6f6b732189c85581fa38a2b52d8065e302b00075701f6cfd.
//
// Solidity: event AcceptBatch(bytes16 arg0, uint256 arg1, uint256 arg2, bool arg3)
func (_Onchain *OnchainFilterer) ParseAcceptBatch(log types.Log) (*OnchainAcceptBatch, error) {
	event := new(OnchainAcceptBatch)
	if err := _Onchain.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainBatchMatchAmountAndProfitIterator is returned from FilterBatchMatchAmountAndProfit and is used to iterate over the raw logs and unpacked data for BatchMatchAmountAndProfit events raised by the Onchain contract.
type OnchainBatchMatchAmountAndProfitIterator struct {
	Event *OnchainBatchMatchAmountAndProfit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainBatchMatchAmountAndProfitIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainBatchMatchAmountAndProfit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainBatchMatchAmountAndProfit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainBatchMatchAmountAndProfitIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainBatchMatchAmountAndProfitIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainBatchMatchAmountAndProfit represents a BatchMatchAmountAndProfit event raised by the Onchain contract.
type OnchainBatchMatchAmountAndProfit struct {
	Arg0 *big.Int
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBatchMatchAmountAndProfit is a free log retrieval operation binding the contract event 0x99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c.
//
// Solidity: event BatchMatchAmountAndProfit(uint256 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterBatchMatchAmountAndProfit(opts *bind.FilterOpts) (*OnchainBatchMatchAmountAndProfitIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "BatchMatchAmountAndProfit")
	if err != nil {
		return nil, err
	}
	return &OnchainBatchMatchAmountAndProfitIterator{contract: _Onchain.contract, event: "BatchMatchAmountAndProfit", logs: logs, sub: sub}, nil
}

// WatchBatchMatchAmountAndProfit is a free log subscription operation binding the contract event 0x99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c.
//
// Solidity: event BatchMatchAmountAndProfit(uint256 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchBatchMatchAmountAndProfit(opts *bind.WatchOpts, sink chan<- *OnchainBatchMatchAmountAndProfit) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "BatchMatchAmountAndProfit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainBatchMatchAmountAndProfit)
				if err := _Onchain.contract.UnpackLog(event, "BatchMatchAmountAndProfit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchMatchAmountAndProfit is a log parse operation binding the contract event 0x99869490c192d9713fc1773145a18b2ef86613027655b38e98d987459bca508c.
//
// Solidity: event BatchMatchAmountAndProfit(uint256 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseBatchMatchAmountAndProfit(log types.Log) (*OnchainBatchMatchAmountAndProfit, error) {
	event := new(OnchainBatchMatchAmountAndProfit)
	if err := _Onchain.contract.UnpackLog(event, "BatchMatchAmountAndProfit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainBatchTimestampIterator is returned from FilterBatchTimestamp and is used to iterate over the raw logs and unpacked data for BatchTimestamp events raised by the Onchain contract.
type OnchainBatchTimestampIterator struct {
	Event *OnchainBatchTimestamp // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainBatchTimestampIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainBatchTimestamp)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainBatchTimestamp)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainBatchTimestampIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainBatchTimestampIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainBatchTimestamp represents a BatchTimestamp event raised by the Onchain contract.
type OnchainBatchTimestamp struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBatchTimestamp is a free log retrieval operation binding the contract event 0x6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f668.
//
// Solidity: event BatchTimestamp(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterBatchTimestamp(opts *bind.FilterOpts) (*OnchainBatchTimestampIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "BatchTimestamp")
	if err != nil {
		return nil, err
	}
	return &OnchainBatchTimestampIterator{contract: _Onchain.contract, event: "BatchTimestamp", logs: logs, sub: sub}, nil
}

// WatchBatchTimestamp is a free log subscription operation binding the contract event 0x6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f668.
//
// Solidity: event BatchTimestamp(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchBatchTimestamp(opts *bind.WatchOpts, sink chan<- *OnchainBatchTimestamp) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "BatchTimestamp")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainBatchTimestamp)
				if err := _Onchain.contract.UnpackLog(event, "BatchTimestamp", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchTimestamp is a log parse operation binding the contract event 0x6f79b986cb819220a660d201db3b4b62109e66c0e2e406a8ca4685376879f668.
//
// Solidity: event BatchTimestamp(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseBatchTimestamp(log types.Log) (*OnchainBatchTimestamp, error) {
	event := new(OnchainBatchTimestamp)
	if err := _Onchain.contract.UnpackLog(event, "BatchTimestamp", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainFullfilMatchIterator is returned from FilterFullfilMatch and is used to iterate over the raw logs and unpacked data for FullfilMatch events raised by the Onchain contract.
type OnchainFullfilMatchIterator struct {
	Event *OnchainFullfilMatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainFullfilMatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainFullfilMatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainFullfilMatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainFullfilMatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainFullfilMatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainFullfilMatch represents a FullfilMatch event raised by the Onchain contract.
type OnchainFullfilMatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFullfilMatch is a free log retrieval operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterFullfilMatch(opts *bind.FilterOpts) (*OnchainFullfilMatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return &OnchainFullfilMatchIterator{contract: _Onchain.contract, event: "FullfilMatch", logs: logs, sub: sub}, nil
}

// WatchFullfilMatch is a free log subscription operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchFullfilMatch(opts *bind.WatchOpts, sink chan<- *OnchainFullfilMatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainFullfilMatch)
				if err := _Onchain.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFullfilMatch is a log parse operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseFullfilMatch(log types.Log) (*OnchainFullfilMatch, error) {
	event := new(OnchainFullfilMatch)
	if err := _Onchain.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainInvalidBatchIterator is returned from FilterInvalidBatch and is used to iterate over the raw logs and unpacked data for InvalidBatch events raised by the Onchain contract.
type OnchainInvalidBatchIterator struct {
	Event *OnchainInvalidBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainInvalidBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainInvalidBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainInvalidBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainInvalidBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainInvalidBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainInvalidBatch represents a InvalidBatch event raised by the Onchain contract.
type OnchainInvalidBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidBatch is a free log retrieval operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterInvalidBatch(opts *bind.FilterOpts) (*OnchainInvalidBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainInvalidBatchIterator{contract: _Onchain.contract, event: "InvalidBatch", logs: logs, sub: sub}, nil
}

// WatchInvalidBatch is a free log subscription operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchInvalidBatch(opts *bind.WatchOpts, sink chan<- *OnchainInvalidBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainInvalidBatch)
				if err := _Onchain.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidBatch is a log parse operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseInvalidBatch(log types.Log) (*OnchainInvalidBatch, error) {
	event := new(OnchainInvalidBatch)
	if err := _Onchain.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainInvalidOrderIterator is returned from FilterInvalidOrder and is used to iterate over the raw logs and unpacked data for InvalidOrder events raised by the Onchain contract.
type OnchainInvalidOrderIterator struct {
	Event *OnchainInvalidOrder // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainInvalidOrderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainInvalidOrder)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainInvalidOrder)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainInvalidOrderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainInvalidOrderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainInvalidOrder represents a InvalidOrder event raised by the Onchain contract.
type OnchainInvalidOrder struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidOrder is a free log retrieval operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterInvalidOrder(opts *bind.FilterOpts) (*OnchainInvalidOrderIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return &OnchainInvalidOrderIterator{contract: _Onchain.contract, event: "InvalidOrder", logs: logs, sub: sub}, nil
}

// WatchInvalidOrder is a free log subscription operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchInvalidOrder(opts *bind.WatchOpts, sink chan<- *OnchainInvalidOrder) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainInvalidOrder)
				if err := _Onchain.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidOrder is a log parse operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseInvalidOrder(log types.Log) (*OnchainInvalidOrder, error) {
	event := new(OnchainInvalidOrder)
	if err := _Onchain.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the Onchain contract.
type OnchainLogAddressIterator struct {
	Event *OnchainLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogAddress represents a LogAddress event raised by the Onchain contract.
type OnchainLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) FilterLogAddress(opts *bind.FilterOpts) (*OnchainLogAddressIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return &OnchainLogAddressIterator{contract: _Onchain.contract, event: "LogAddress", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *OnchainLogAddress) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogAddress)
				if err := _Onchain.contract.UnpackLog(event, "LogAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_Onchain *OnchainFilterer) ParseLogAddress(log types.Log) (*OnchainLogAddress, error) {
	event := new(OnchainLogAddress)
	if err := _Onchain.contract.UnpackLog(event, "LogAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the Onchain contract.
type OnchainLogBytesIterator struct {
	Event *OnchainLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes represents a LogBytes event raised by the Onchain contract.
type OnchainLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes(opts *bind.FilterOpts) (*OnchainLogBytesIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytesIterator{contract: _Onchain.contract, event: "LogBytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes(log types.Log) (*OnchainLogBytes, error) {
	event := new(OnchainLogBytes)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytes16Iterator is returned from FilterLogBytes16 and is used to iterate over the raw logs and unpacked data for LogBytes16 events raised by the Onchain contract.
type OnchainLogBytes16Iterator struct {
	Event *OnchainLogBytes16 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytes16Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes16)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes16)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytes16Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytes16Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes16 represents a LogBytes16 event raised by the Onchain contract.
type OnchainLogBytes16 struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes16 is a free log retrieval operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes16(opts *bind.FilterOpts) (*OnchainLogBytes16Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytes16Iterator{contract: _Onchain.contract, event: "LogBytes16", logs: logs, sub: sub}, nil
}

// WatchLogBytes16 is a free log subscription operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes16(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes16) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes16)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes16", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes16 is a log parse operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes16(log types.Log) (*OnchainLogBytes16, error) {
	event := new(OnchainLogBytes16)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes16", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the Onchain contract.
type OnchainLogBytes32Iterator struct {
	Event *OnchainLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogBytes32 represents a LogBytes32 event raised by the Onchain contract.
type OnchainLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*OnchainLogBytes32Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return &OnchainLogBytes32Iterator{contract: _Onchain.contract, event: "LogBytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *OnchainLogBytes32) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogBytes32)
				if err := _Onchain.contract.UnpackLog(event, "LogBytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_Onchain *OnchainFilterer) ParseLogBytes32(log types.Log) (*OnchainLogBytes32, error) {
	event := new(OnchainLogBytes32)
	if err := _Onchain.contract.UnpackLog(event, "LogBytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogRecoverErrorIterator is returned from FilterLogRecoverError and is used to iterate over the raw logs and unpacked data for LogRecoverError events raised by the Onchain contract.
type OnchainLogRecoverErrorIterator struct {
	Event *OnchainLogRecoverError // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogRecoverErrorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogRecoverError)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogRecoverError)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogRecoverErrorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogRecoverErrorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogRecoverError represents a LogRecoverError event raised by the Onchain contract.
type OnchainLogRecoverError struct {
	Arg0 uint8
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogRecoverError is a free log retrieval operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) FilterLogRecoverError(opts *bind.FilterOpts) (*OnchainLogRecoverErrorIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return &OnchainLogRecoverErrorIterator{contract: _Onchain.contract, event: "LogRecoverError", logs: logs, sub: sub}, nil
}

// WatchLogRecoverError is a free log subscription operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) WatchLogRecoverError(opts *bind.WatchOpts, sink chan<- *OnchainLogRecoverError) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogRecoverError)
				if err := _Onchain.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogRecoverError is a log parse operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_Onchain *OnchainFilterer) ParseLogRecoverError(log types.Log) (*OnchainLogRecoverError, error) {
	event := new(OnchainLogRecoverError)
	if err := _Onchain.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the Onchain contract.
type OnchainLogStringIterator struct {
	Event *OnchainLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogString represents a LogString event raised by the Onchain contract.
type OnchainLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) FilterLogString(opts *bind.FilterOpts) (*OnchainLogStringIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return &OnchainLogStringIterator{contract: _Onchain.contract, event: "LogString", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *OnchainLogString) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogString)
				if err := _Onchain.contract.UnpackLog(event, "LogString", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_Onchain *OnchainFilterer) ParseLogString(log types.Log) (*OnchainLogString, error) {
	event := new(OnchainLogString)
	if err := _Onchain.contract.UnpackLog(event, "LogString", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainLogUint256Iterator is returned from FilterLogUint256 and is used to iterate over the raw logs and unpacked data for LogUint256 events raised by the Onchain contract.
type OnchainLogUint256Iterator struct {
	Event *OnchainLogUint256 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainLogUint256Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainLogUint256)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainLogUint256)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainLogUint256Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainLogUint256Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainLogUint256 represents a LogUint256 event raised by the Onchain contract.
type OnchainLogUint256 struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint256 is a free log retrieval operation binding the contract event 0x535266f26566acd2ef175615d9f1140b36f149b810b33fb93143236a69912c32.
//
// Solidity: event LogUint256(uint256 arg0)
func (_Onchain *OnchainFilterer) FilterLogUint256(opts *bind.FilterOpts) (*OnchainLogUint256Iterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "LogUint256")
	if err != nil {
		return nil, err
	}
	return &OnchainLogUint256Iterator{contract: _Onchain.contract, event: "LogUint256", logs: logs, sub: sub}, nil
}

// WatchLogUint256 is a free log subscription operation binding the contract event 0x535266f26566acd2ef175615d9f1140b36f149b810b33fb93143236a69912c32.
//
// Solidity: event LogUint256(uint256 arg0)
func (_Onchain *OnchainFilterer) WatchLogUint256(opts *bind.WatchOpts, sink chan<- *OnchainLogUint256) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "LogUint256")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainLogUint256)
				if err := _Onchain.contract.UnpackLog(event, "LogUint256", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint256 is a log parse operation binding the contract event 0x535266f26566acd2ef175615d9f1140b36f149b810b33fb93143236a69912c32.
//
// Solidity: event LogUint256(uint256 arg0)
func (_Onchain *OnchainFilterer) ParseLogUint256(log types.Log) (*OnchainLogUint256, error) {
	event := new(OnchainLogUint256)
	if err := _Onchain.contract.UnpackLog(event, "LogUint256", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainMatchedPriceIterator is returned from FilterMatchedPrice and is used to iterate over the raw logs and unpacked data for MatchedPrice events raised by the Onchain contract.
type OnchainMatchedPriceIterator struct {
	Event *OnchainMatchedPrice // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainMatchedPriceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainMatchedPrice)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainMatchedPrice)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainMatchedPriceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainMatchedPriceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainMatchedPrice represents a MatchedPrice event raised by the Onchain contract.
type OnchainMatchedPrice struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterMatchedPrice is a free log retrieval operation binding the contract event 0x21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7.
//
// Solidity: event MatchedPrice(uint256 arg0)
func (_Onchain *OnchainFilterer) FilterMatchedPrice(opts *bind.FilterOpts) (*OnchainMatchedPriceIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "MatchedPrice")
	if err != nil {
		return nil, err
	}
	return &OnchainMatchedPriceIterator{contract: _Onchain.contract, event: "MatchedPrice", logs: logs, sub: sub}, nil
}

// WatchMatchedPrice is a free log subscription operation binding the contract event 0x21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7.
//
// Solidity: event MatchedPrice(uint256 arg0)
func (_Onchain *OnchainFilterer) WatchMatchedPrice(opts *bind.WatchOpts, sink chan<- *OnchainMatchedPrice) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "MatchedPrice")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainMatchedPrice)
				if err := _Onchain.contract.UnpackLog(event, "MatchedPrice", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMatchedPrice is a log parse operation binding the contract event 0x21331f5f70f88dca9a2b9b06c6cf44878ab0c9e6a395bca9385b8de7163fb3e7.
//
// Solidity: event MatchedPrice(uint256 arg0)
func (_Onchain *OnchainFilterer) ParseMatchedPrice(log types.Log) (*OnchainMatchedPrice, error) {
	event := new(OnchainMatchedPrice)
	if err := _Onchain.contract.UnpackLog(event, "MatchedPrice", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainPunishMatcherIterator is returned from FilterPunishMatcher and is used to iterate over the raw logs and unpacked data for PunishMatcher events raised by the Onchain contract.
type OnchainPunishMatcherIterator struct {
	Event *OnchainPunishMatcher // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainPunishMatcherIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainPunishMatcher)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainPunishMatcher)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainPunishMatcherIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainPunishMatcherIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainPunishMatcher represents a PunishMatcher event raised by the Onchain contract.
type OnchainPunishMatcher struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPunishMatcher is a free log retrieval operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) FilterPunishMatcher(opts *bind.FilterOpts) (*OnchainPunishMatcherIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return &OnchainPunishMatcherIterator{contract: _Onchain.contract, event: "PunishMatcher", logs: logs, sub: sub}, nil
}

// WatchPunishMatcher is a free log subscription operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) WatchPunishMatcher(opts *bind.WatchOpts, sink chan<- *OnchainPunishMatcher) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainPunishMatcher)
				if err := _Onchain.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePunishMatcher is a log parse operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_Onchain *OnchainFilterer) ParsePunishMatcher(log types.Log) (*OnchainPunishMatcher, error) {
	event := new(OnchainPunishMatcher)
	if err := _Onchain.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainReceivedBatchDetailsIterator is returned from FilterReceivedBatchDetails and is used to iterate over the raw logs and unpacked data for ReceivedBatchDetails events raised by the Onchain contract.
type OnchainReceivedBatchDetailsIterator struct {
	Event *OnchainReceivedBatchDetails // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainReceivedBatchDetailsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainReceivedBatchDetails)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainReceivedBatchDetails)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainReceivedBatchDetailsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainReceivedBatchDetailsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainReceivedBatchDetails represents a ReceivedBatchDetails event raised by the Onchain contract.
type OnchainReceivedBatchDetails struct {
	Arg0 [16]byte
	Arg1 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterReceivedBatchDetails is a free log retrieval operation binding the contract event 0xd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) FilterReceivedBatchDetails(opts *bind.FilterOpts) (*OnchainReceivedBatchDetailsIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return &OnchainReceivedBatchDetailsIterator{contract: _Onchain.contract, event: "ReceivedBatchDetails", logs: logs, sub: sub}, nil
}

// WatchReceivedBatchDetails is a free log subscription operation binding the contract event 0xd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) WatchReceivedBatchDetails(opts *bind.WatchOpts, sink chan<- *OnchainReceivedBatchDetails) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainReceivedBatchDetails)
				if err := _Onchain.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseReceivedBatchDetails is a log parse operation binding the contract event 0xd55425a5fdfbfd51b556071465ab893c0ed4d05807e813f5f490cac8a93b316b.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0, uint256 arg1)
func (_Onchain *OnchainFilterer) ParseReceivedBatchDetails(log types.Log) (*OnchainReceivedBatchDetails, error) {
	event := new(OnchainReceivedBatchDetails)
	if err := _Onchain.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainRemoveBatchOutOfDateIterator is returned from FilterRemoveBatchOutOfDate and is used to iterate over the raw logs and unpacked data for RemoveBatchOutOfDate events raised by the Onchain contract.
type OnchainRemoveBatchOutOfDateIterator struct {
	Event *OnchainRemoveBatchOutOfDate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainRemoveBatchOutOfDateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainRemoveBatchOutOfDate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainRemoveBatchOutOfDate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainRemoveBatchOutOfDateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainRemoveBatchOutOfDateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainRemoveBatchOutOfDate represents a RemoveBatchOutOfDate event raised by the Onchain contract.
type OnchainRemoveBatchOutOfDate struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRemoveBatchOutOfDate is a free log retrieval operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterRemoveBatchOutOfDate(opts *bind.FilterOpts) (*OnchainRemoveBatchOutOfDateIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return &OnchainRemoveBatchOutOfDateIterator{contract: _Onchain.contract, event: "RemoveBatchOutOfDate", logs: logs, sub: sub}, nil
}

// WatchRemoveBatchOutOfDate is a free log subscription operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchRemoveBatchOutOfDate(opts *bind.WatchOpts, sink chan<- *OnchainRemoveBatchOutOfDate) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainRemoveBatchOutOfDate)
				if err := _Onchain.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRemoveBatchOutOfDate is a log parse operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseRemoveBatchOutOfDate(log types.Log) (*OnchainRemoveBatchOutOfDate, error) {
	event := new(OnchainRemoveBatchOutOfDate)
	if err := _Onchain.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainRevertBatchIterator is returned from FilterRevertBatch and is used to iterate over the raw logs and unpacked data for RevertBatch events raised by the Onchain contract.
type OnchainRevertBatchIterator struct {
	Event *OnchainRevertBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainRevertBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainRevertBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainRevertBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainRevertBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainRevertBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainRevertBatch represents a RevertBatch event raised by the Onchain contract.
type OnchainRevertBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRevertBatch is a free log retrieval operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) FilterRevertBatch(opts *bind.FilterOpts) (*OnchainRevertBatchIterator, error) {

	logs, sub, err := _Onchain.contract.FilterLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainRevertBatchIterator{contract: _Onchain.contract, event: "RevertBatch", logs: logs, sub: sub}, nil
}

// WatchRevertBatch is a free log subscription operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) WatchRevertBatch(opts *bind.WatchOpts, sink chan<- *OnchainRevertBatch) (event.Subscription, error) {

	logs, sub, err := _Onchain.contract.WatchLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainRevertBatch)
				if err := _Onchain.contract.UnpackLog(event, "RevertBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRevertBatch is a log parse operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_Onchain *OnchainFilterer) ParseRevertBatch(log types.Log) (*OnchainRevertBatch, error) {
	event := new(OnchainRevertBatch)
	if err := _Onchain.contract.UnpackLog(event, "RevertBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
