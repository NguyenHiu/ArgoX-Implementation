// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package onchain_V1

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// OnchainV1Batch is an auto generated low-level Go binding around an user-defined struct.
type OnchainV1Batch struct {
	BatchID   [16]byte
	Price     *big.Int
	Amount    *big.Int
	Side      bool
	Owner     common.Address
	Signature []byte
	Time      *big.Int
}

// OnchainV1Order is an auto generated low-level Go binding around an user-defined struct.
type OnchainV1Order struct {
	Price             *big.Int
	Amount            *big.Int
	Side              bool
	From              [16]byte
	TradeHash         [32]byte
	OriginalOrderHash [32]byte
}

// OnchainV1MetaData contains all meta data concerning the OnchainV1 contract.
var OnchainV1MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"StringsInsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"AcceptBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"FullfilMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"InvalidOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"LogBytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"LogBytes16\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"LogBytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumECDSA.RecoverError\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"LogRecoverError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"PartialMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PunishMatcher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"ReceivedBatchDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RemoveBatchOutOfDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"RevertBatch\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GetAskOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"structOnchain_V1.Batch[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetBidOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"structOnchain_V1.Batch[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"deleteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"isMatcher\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"isPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_m\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"}],\"name\":\"reportMissingDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sign\",\"type\":\"bytes\"}],\"name\":\"sendBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"bytes16\",\"name\":\"from\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"originalOrderHash\",\"type\":\"bytes32\"}],\"internalType\":\"structOnchain_V1.Order[]\",\"name\":\"_ords\",\"type\":\"tuple[]\"}],\"name\":\"submitOrderDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"uintToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"batchID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561000f575f80fd5b50670de0b6b3a76400006002819055506005600381905550614751806100345f395ff3fe6080604052600436106100dc575f3560e01c80635e57966d1161007e5780638545dca2116100585780638545dca2146102a657806385d8a4e6146102d0578063b29e6299146102f8578063e939567914610320576100dc565b80635e57966d1461021a57806378b32cf51461025657806382736cd71461027e576100dc565b806336ee6749116100ba57806336ee67491461016e5780634420e486146101aa5780634dcbd09b146101c657806355a33968146101f0576100dc565b806319f5e9fe146100e05780633005d34c1461011c57806332a58e7914610144575b5f80fd5b3480156100eb575f80fd5b5061010660048036038101906101019190613392565b61035c565b60405161011391906133d7565b60405180910390f35b348015610127575f80fd5b50610142600480360381019061013d91906135e3565b6103f4565b005b34801561014f575f80fd5b5061015861049e565b6040516101659190613697565b60405180910390f35b348015610179575f80fd5b50610194600480360381019061018f91906136b0565b6104a7565b6040516101a191906133d7565b60405180910390f35b6101c460048036038101906101bf91906136b0565b6104f0565b005b3480156101d1575f80fd5b506101da61057c565b6040516101e79190613697565b60405180910390f35b3480156101fb575f80fd5b50610204610585565b60405161021191906138e5565b60405180910390f35b348015610225575f80fd5b50610240600480360381019061023b91906136b0565b610739565b60405161024d9190613957565b60405180910390f35b348015610261575f80fd5b5061027c60048036038101906102779190613392565b610763565b005b348015610289575f80fd5b506102a4600480360381019061029f9190613977565b610ab6565b005b3480156102b1575f80fd5b506102ba610cf6565b6040516102c791906138e5565b60405180910390f35b3480156102db575f80fd5b506102f660048036038101906102f19190613b4d565b610eab565b005b348015610303575f80fd5b5061031e60048036038101906103199190613392565b6114f7565b005b34801561032b575f80fd5b5061034660048036038101906103419190613ba7565b6117ae565b6040516103539190613957565b60405180910390f35b5f8060055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154141580156103ed57504260035460055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501546103eb9190613bff565b105b9050919050565b7f48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d866040516104239190613c41565b60405180910390a15f6040518060e00160405280886fffffffffffffffffffffffffffffffff1916815260200187815260200186815260200185151581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018381526020015f8152509050610495816117c0565b50505050505050565b5f600254905090565b5f8060045f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205414159050919050565b600254341015610535576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161052c90613ca4565b60405180910390fd5b60025460045f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208190555050565b5f600354905090565b60605f805480602002602001604051908101604052809291908181526020015f905b82821015610730578382905f5260205f2090600602016040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160048201805461069790613cef565b80601f01602080910402602001604051908101604052809291908181526020018280546106c390613cef565b801561070e5780601f106106e55761010080835404028352916020019161070e565b820191905f5260205f20905b8154815290600101906020018083116106f157829003601f168201915b50505050508152602001600582015481525050815260200190600101906105a7565b50505050905090565b606061075c8273ffffffffffffffffffffffffffffffffffffffff1660146117f2565b9050919050565b805f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154036107e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107d790613d69565b60405180910390fd5b4260035460055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501546108299190613bff565b10610869576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086090613dd1565b60405180910390fd5b5f60045f60055f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055505f60055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055505f60065f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b905060065f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154906fffffffffffffffffffffffffffffffff02191690556109e981611a30565b7fef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b66022083604051610a189190613c41565b60405180910390a17f5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba2360055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604051610aa99190613dfe565b60405180910390a1505050565b813373ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b7f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b7690613e61565b60405180910390fd5b825f73ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610c48576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c3f90613ec9565b60405180910390fd5b60055f856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff1615610ca457610c9f5f8585611cba565b610cb1565b610cb060018585611cba565b5b8260055f866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002018190555050505050565b60606001805480602002602001604051908101604052809291908181526020015f905b82821015610ea2578382905f5260205f2090600602016040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600482018054610e0990613cef565b80601f0160208091040260200160405190810160405280929190818152602001828054610e3590613cef565b8015610e805780601f10610e5757610100808354040283529160200191610e80565b820191905f5260205f20905b815481529060010190602001808311610e6357829003601f168201915b5050505050815260200160058201548152505081526020019060010190610d19565b50505050905090565b815f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206005015403610f28576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f1f90613d69565b60405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610ff1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fe890613e61565b60405180910390fd5b5f60605f5b85518160ff16101561111757858160ff168151811061101857611017613ee7565b5b6020026020010151602001518361102f9190613bff565b925081868260ff168151811061104857611047613ee7565b5b60200260200101515f0151878360ff168151811061106957611068613ee7565b5b602002602001015160200151888460ff168151811061108b5761108a613ee7565b5b602002602001015160400151898560ff16815181106110ad576110ac613ee7565b5b6020026020010151606001516040516020016110cc9493929190613f99565b604051602081830303815290604052805190602001206040516020016110f3929190614040565b6040516020818303038152906040529150808061110f90614073565b915050610ff6565b5060055f876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600201548214611197577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748866040516111889190613c41565b60405180910390a150506114f1565b5f6113a98760055f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206001015460055f8b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206002015460055f8c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff168a518760055f8f6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516020016112cd97969594939291906140f7565b6040516020818303038152906040528051906020012060055f8a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600401805461132890613cef565b80601f016020809104026020016040519081016040528092919081815260200182805461135490613cef565b801561139f5780601f106113765761010080835404028352916020019161139f565b820191905f5260205f20905b81548152906001019060200180831161138257829003601f168201915b5050505050611d61565b905060055f886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611477577fe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748876040516114679190613c41565b60405180910390a15050506114f1565b5f60055f896fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f20600501819055507f9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e876040516114e59190613c41565b60405180910390a15050505b50505050565b803373ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146115c0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115b790613e61565b60405180910390fd5b815f73ffffffffffffffffffffffffffffffffffffffff1660055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060030160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603611689576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161168090613ec9565b60405180910390fd5b60055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206003015f9054906101000a900460ff16156116e4576116df5f84611d8b565b6116f0565b6116ef600184611d8b565b5b60055f846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f8082015f6101000a8154906fffffffffffffffffffffffffffffffff0219169055600182015f9055600282015f9055600382015f6101000a81549060ff02191690556003820160016101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055600482015f6117a091906132d4565b600582015f90555050505050565b60606117b98261201c565b9050919050565b8060600151156117da576117d45f826120e6565b506117e7565b6117e56001826120e6565b505b6117ef6126a0565b50565b60605f8390505f60028460026118089190614173565b6118129190613bff565b67ffffffffffffffff81111561182b5761182a6134bf565b5b6040519080825280601f01601f19166020018201604052801561185d5781602001600182028036833780820191505090505b5090507f3000000000000000000000000000000000000000000000000000000000000000815f8151811061189457611893613ee7565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053507f7800000000000000000000000000000000000000000000000000000000000000816001815181106118f7576118f6613ee7565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505f60018560026119359190614173565b61193f9190613bff565b90505b60018111156119de577f3031323334353637383961626364656600000000000000000000000000000000600f84166010811061198157611980613ee7565b5b1a60f81b82828151811061199857611997613ee7565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600483901c9250806119d7906141b4565b9050611942565b505f8214611a255784846040517fe22e27eb000000000000000000000000000000000000000000000000000000008152600401611a1c9291906141db565b60405180910390fd5b809250505092915050565b5f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f2060050154148015611ad257505f60801b60065f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f9054906101000a900460801b6fffffffffffffffffffffffffffffffff191614155b15611cb7577ff335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd681604051611b069190613c41565b60405180910390a15f60055f836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f206040518060e00160405290815f82015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020016001820154815260200160028201548152602001600382015f9054906101000a900460ff161515151581526020016003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600482018054611c2090613cef565b80601f0160208091040260200160405190810160405280929190818152602001828054611c4c90613cef565b8015611c975780601f10611c6e57610100808354040283529160200191611c97565b820191905f5260205f20905b815481529060010190602001808311611c7a57829003601f168201915b505050505081526020016005820154815250509050611cb5816117c0565b505b50565b5f5b8380549050811015611d5b57826fffffffffffffffffffffffffffffffff1916848281548110611cef57611cee613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff191603611d4e5781848281548110611d3657611d35613ee7565b5b905f5260205f20906006020160020181905550611d5b565b8080600101915050611cbc565b50505050565b5f805f80611d6f8686612ee5565b925092509250611d7f8282612f3a565b82935050505092915050565b5f805b60018480549050611d9f9190614202565b811015611f6f5781158015611e065750826fffffffffffffffffffffffffffffffff1916848281548110611dd657611dd5613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff1916145b15611e1057600191505b8115611f625783600182611e249190613bff565b81548110611e3557611e34613ee7565b5b905f5260205f209060060201848281548110611e5457611e53613ee7565b5b905f5260205f2090600602015f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048201816004019081611f5391906143e7565b50600582015481600501559050505b8080600101915050611d8e565b5082805480611f8157611f806144cc565b5b600190038181905f5260205f2090600602015f8082015f6101000a8154906fffffffffffffffffffffffffffffffff0219169055600182015f9055600282015f9055600382015f6101000a81549060ff02191690556003820160016101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055600482015f61200c91906132d4565b600582015f905550509055505050565b60605f600161202a8461309c565b0190505f8167ffffffffffffffff811115612048576120476134bf565b5b6040519080825280601f01601f19166020018201604052801561207a5781602001600182028036833780820191505090505b5090505f82602001820190505b6001156120db578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a85816120d0576120cf6144f9565b5b0494505f8503612087575b819350505050919050565b5f807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905082606001511561211a57600190505b5f84805490501480612178575080846001868054905061213a9190614202565b8154811061214b5761214a613ee7565b5b905f5260205f20906006020160010154612165919061452f565b818460200151612175919061452f565b13155b15612273578383908060018154018082558091505060019003905f5260205f2090600602015f909190919091505f820151815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555060208201518160010155604082015181600201556060820151816003015f6101000a81548160ff02191690831515021790555060808201518160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060a082015181600401908161226191906145a5565b5060c082015181600501555050612695565b5f5b8480549050811015612693578185828154811061229557612294613ee7565b5b905f5260205f209060060201600101546122af919061452f565b8285602001516122bf919061452f565b1315612686578485600187805490506122d89190614202565b815481106122e9576122e8613ee7565b5b905f5260205f209060060201908060018154018082558091505060019003905f5260205f2090600602015f909190919091505f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506004820181600401908161240e91906143e7565b506005820154816005015550505f6002868054905061242d9190614202565b90505b8181111561259657856001826124469190614202565b8154811061245757612456613ee7565b5b905f5260205f20906006020186828154811061247657612475613ee7565b5b905f5260205f2090600602015f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506004820181600401908161257591906143e7565b5060058201548160050155905050808061258e906141b4565b915050612430565b50838582815481106125ab576125aa613ee7565b5b905f5260205f2090600602015f820151815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555060208201518160010155604082015181600201556060820151816003015f6101000a81548160ff02191690831515021790555060808201518160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060a082015181600401908161267391906145a5565b5060c08201518160050155905050612693565b8080600101915050612275565b505b600191505092915050565b5b5f8080549050141580156126ba57505f60018054905014155b801561270b575060015f815481106126d5576126d4613ee7565b5b905f5260205f209060060201600101545f80815481106126f8576126f7613ee7565b5b905f5260205f2090600602016001015410155b15612ee35760015f8154811061272457612723613ee7565b5b905f5260205f209060060201600201545f808154811061274757612746613ee7565b5b905f5260205f2090600602016002015411156127f55760015f8154811061277157612770613ee7565b5b905f5260205f209060060201600201545f808154811061279457612793613ee7565b5b905f5260205f2090600602016002015f8282546127b19190614202565b925050819055506127f06001805f815481106127d0576127cf613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b611d8b565b612ede565b60015f8154811061280957612808613ee7565b5b905f5260205f209060060201600201545f808154811061282c5761282b613ee7565b5b905f5260205f2090600602016002015410156128d9575f808154811061285557612854613ee7565b5b905f5260205f2090600602016002015460015f8154811061287957612878613ee7565b5b905f5260205f2090600602016002015f8282546128969190614202565b925050819055506128d45f805f815481106128b4576128b3613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b611d8b565b612edd565b425f80815481106128ed576128ec613ee7565b5b905f5260205f209060060201600501819055505f808154811061291357612912613ee7565b5b905f5260205f20906006020160055f805f8154811061293557612934613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048201816004019081612a7691906143e7565b50600582015481600501559050504260015f81548110612a9957612a98613ee7565b5b905f5260205f2090600602016005018190555060015f81548110612ac057612abf613ee7565b5b905f5260205f20906006020160055f60015f81548110612ae357612ae2613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f82015f9054906101000a900460801b815f015f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055506001820154816001015560028201548160020155600382015f9054906101000a900460ff16816003015f6101000a81548160ff0219169083151502179055506003820160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160030160016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048201816004019081612c2491906143e7565b506005820154816005015590505060015f81548110612c4657612c45613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b60065f805f81548110612c7757612c76613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055505f8081548110612cfe57612cfd613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b60065f60015f81548110612d3057612d2f613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020015f205f6101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055507f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae9655f8081548110612dd857612dd7613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b604051612e009190613c41565b60405180910390a17f57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae96560015f81548110612e3d57612e3c613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b604051612e659190613c41565b60405180910390a1612ea56001805f81548110612e8557612e84613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b611d8b565b612edc5f805f81548110612ebc57612ebb613ee7565b5b905f5260205f2090600602015f015f9054906101000a900460801b611d8b565b5b5b6126a1565b565b5f805f6041845103612f25575f805f602087015192506040870151915060608701515f1a9050612f17888285856131ed565b955095509550505050612f33565b5f600285515f1b9250925092505b9250925092565b5f6003811115612f4d57612f4c614674565b5b826003811115612f6057612f5f614674565b5b03156130985760016003811115612f7a57612f79614674565b5b826003811115612f8d57612f8c614674565b5b03612fc4576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115612fd857612fd7614674565b5b826003811115612feb57612fea614674565b5b0361302f57805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016130269190613697565b60405180910390fd5b60038081111561304257613041614674565b5b82600381111561305557613054614674565b5b0361309757806040517fd78bce0c00000000000000000000000000000000000000000000000000000000815260040161308e91906146b0565b60405180910390fd5b5b5050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106130f8577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816130ee576130ed6144f9565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310613135576d04ee2d6d415b85acef8100000000838161312b5761312a6144f9565b5b0492506020810190505b662386f26fc10000831061316457662386f26fc10000838161315a576131596144f9565b5b0492506010810190505b6305f5e100831061318d576305f5e1008381613183576131826144f9565b5b0492506008810190505b61271083106131b25761271083816131a8576131a76144f9565b5b0492506004810190505b606483106131d557606483816131cb576131ca6144f9565b5b0492506002810190505b600a83106131e4576001810190505b80915050919050565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115613229575f6003859250925092506132ca565b5f6001888888886040515f815260200160405260405161324c94939291906146d8565b6020604051602081039080840390855afa15801561326c573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036132bd575f60015f801b935093509350506132ca565b805f805f1b935093509350505b9450945094915050565b5080546132e090613cef565b5f825580601f106132f1575061330e565b601f0160209004905f5260205f209081019061330d9190613311565b5b50565b5b80821115613328575f815f905550600101613312565b5090565b5f604051905090565b5f80fd5b5f80fd5b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6133718161333d565b811461337b575f80fd5b50565b5f8135905061338c81613368565b92915050565b5f602082840312156133a7576133a6613335565b5b5f6133b48482850161337e565b91505092915050565b5f8115159050919050565b6133d1816133bd565b82525050565b5f6020820190506133ea5f8301846133c8565b92915050565b5f819050919050565b613402816133f0565b811461340c575f80fd5b50565b5f8135905061341d816133f9565b92915050565b61342c816133bd565b8114613436575f80fd5b50565b5f8135905061344781613423565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6134768261344d565b9050919050565b6134868161346c565b8114613490575f80fd5b50565b5f813590506134a18161347d565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6134f5826134af565b810181811067ffffffffffffffff82111715613514576135136134bf565b5b80604052505050565b5f61352661332c565b905061353282826134ec565b919050565b5f67ffffffffffffffff821115613551576135506134bf565b5b61355a826134af565b9050602081019050919050565b828183375f83830152505050565b5f61358761358284613537565b61351d565b9050828152602081018484840111156135a3576135a26134ab565b5b6135ae848285613567565b509392505050565b5f82601f8301126135ca576135c96134a7565b5b81356135da848260208601613575565b91505092915050565b5f805f805f8060c087890312156135fd576135fc613335565b5b5f61360a89828a0161337e565b965050602061361b89828a0161340f565b955050604061362c89828a0161340f565b945050606061363d89828a01613439565b935050608061364e89828a01613493565b92505060a087013567ffffffffffffffff81111561366f5761366e613339565b5b61367b89828a016135b6565b9150509295509295509295565b613691816133f0565b82525050565b5f6020820190506136aa5f830184613688565b92915050565b5f602082840312156136c5576136c4613335565b5b5f6136d284828501613493565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b61370d8161333d565b82525050565b61371c816133f0565b82525050565b61372b816133bd565b82525050565b61373a8161346c565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f5b8381101561377757808201518184015260208101905061375c565b5f8484015250505050565b5f61378c82613740565b613796818561374a565b93506137a681856020860161375a565b6137af816134af565b840191505092915050565b5f60e083015f8301516137cf5f860182613704565b5060208301516137e26020860182613713565b5060408301516137f56040860182613713565b5060608301516138086060860182613722565b50608083015161381b6080860182613731565b5060a083015184820360a08601526138338282613782565b91505060c083015161384860c0860182613713565b508091505092915050565b5f61385e83836137ba565b905092915050565b5f602082019050919050565b5f61387c826136db565b61388681856136e5565b935083602082028501613898856136f5565b805f5b858110156138d357848403895281516138b48582613853565b94506138bf83613866565b925060208a0199505060018101905061389b565b50829750879550505050505092915050565b5f6020820190508181035f8301526138fd8184613872565b905092915050565b5f81519050919050565b5f82825260208201905092915050565b5f61392982613905565b613933818561390f565b935061394381856020860161375a565b61394c816134af565b840191505092915050565b5f6020820190508181035f83015261396f818461391f565b905092915050565b5f806040838503121561398d5761398c613335565b5b5f61399a8582860161337e565b92505060206139ab8582860161340f565b9150509250929050565b5f67ffffffffffffffff8211156139cf576139ce6134bf565b5b602082029050602081019050919050565b5f80fd5b5f80fd5b5f819050919050565b6139fa816139e8565b8114613a04575f80fd5b50565b5f81359050613a15816139f1565b92915050565b5f60c08284031215613a3057613a2f6139e4565b5b613a3a60c061351d565b90505f613a498482850161340f565b5f830152506020613a5c8482850161340f565b6020830152506040613a7084828501613439565b6040830152506060613a848482850161337e565b6060830152506080613a9884828501613a07565b60808301525060a0613aac84828501613a07565b60a08301525092915050565b5f613aca613ac5846139b5565b61351d565b90508083825260208201905060c08402830185811115613aed57613aec6139e0565b5b835b81811015613b165780613b028882613a1b565b84526020840193505060c081019050613aef565b5050509392505050565b5f82601f830112613b3457613b336134a7565b5b8135613b44848260208601613ab8565b91505092915050565b5f8060408385031215613b6357613b62613335565b5b5f613b708582860161337e565b925050602083013567ffffffffffffffff811115613b9157613b90613339565b5b613b9d85828601613b20565b9150509250929050565b5f60208284031215613bbc57613bbb613335565b5b5f613bc98482850161340f565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f613c09826133f0565b9150613c14836133f0565b9250828201905080821115613c2c57613c2b613bd2565b5b92915050565b613c3b8161333d565b82525050565b5f602082019050613c545f830184613c32565b92915050565b7f726567697374657220666565206973206e6f7420656e6f7567680000000000005f82015250565b5f613c8e601a8361390f565b9150613c9982613c5a565b602082019050919050565b5f6020820190508181035f830152613cbb81613c82565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680613d0657607f821691505b602082108103613d1957613d18613cc2565b5b50919050565b7f746865206261746368206973206e6f742070656e64696e6700000000000000005f82015250565b5f613d5360188361390f565b9150613d5e82613d1f565b602082019050919050565b5f6020820190508181035f830152613d8081613d47565b9050919050565b7f746865206261746368206973206e6f74206f75742d6f662d64617465000000005f82015250565b5f613dbb601c8361390f565b9150613dc682613d87565b602082019050919050565b5f6020820190508181035f830152613de881613daf565b9050919050565b613df88161346c565b82525050565b5f602082019050613e115f830184613def565b92915050565b7f726571756972652062617463682773206f0000000000000000000000000000005f82015250565b5f613e4b60118361390f565b9150613e5682613e17565b602082019050919050565b5f6020820190508181035f830152613e7881613e3f565b9050919050565b7f74686520626174636820646f6573206e6f7420657869737400000000000000005f82015250565b5f613eb360188361390f565b9150613ebe82613e7f565b602082019050919050565b5f6020820190508181035f830152613ee081613ea7565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f819050919050565b613f2e613f29826133f0565b613f14565b82525050565b5f8160f81b9050919050565b5f613f4a82613f34565b9050919050565b5f613f5b82613f40565b9050919050565b613f73613f6e826133bd565b613f51565b82525050565b5f819050919050565b613f93613f8e8261333d565b613f79565b82525050565b5f613fa48287613f1d565b602082019150613fb48286613f1d565b602082019150613fc48285613f62565b600182019150613fd48284613f82565b60108201915081905095945050505050565b5f81905092915050565b5f613ffa82613740565b6140048185613fe6565b935061401481856020860161375a565b80840191505092915050565b5f819050919050565b61403a614035826139e8565b614020565b82525050565b5f61404b8285613ff0565b91506140578284614029565b6020820191508190509392505050565b5f60ff82169050919050565b5f61407d82614067565b915060ff82036140905761408f613bd2565b5b600182019050919050565b6140ac6140a782614067565b613f40565b82525050565b5f8160601b9050919050565b5f6140c8826140b2565b9050919050565b5f6140d9826140be565b9050919050565b6140f16140ec8261346c565b6140cf565b82525050565b5f614102828a613f82565b6010820191506141128289613f1d565b6020820191506141228288613f1d565b6020820191506141328287613f62565b600182019150614142828661409b565b6001820191506141528285613ff0565b915061415e82846140e0565b60148201915081905098975050505050505050565b5f61417d826133f0565b9150614188836133f0565b9250828202614196816133f0565b915082820484148315176141ad576141ac613bd2565b5b5092915050565b5f6141be826133f0565b91505f82036141d0576141cf613bd2565b5b600182039050919050565b5f6040820190506141ee5f830185613688565b6141fb6020830184613688565b9392505050565b5f61420c826133f0565b9150614217836133f0565b925082820390508181111561422f5761422e613bd2565b5b92915050565b5f8154905061424381613cef565b9050919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026142a67fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261426b565b6142b0868361426b565b95508019841693508086168417925050509392505050565b5f819050919050565b5f6142eb6142e66142e1846133f0565b6142c8565b6133f0565b9050919050565b5f819050919050565b614304836142d1565b614318614310826142f2565b848454614277565b825550505050565b5f90565b61432c614320565b6143378184846142fb565b505050565b5b8181101561435a5761434f5f82614324565b60018101905061433d565b5050565b601f82111561439f576143708161424a565b6143798461425c565b81016020851015614388578190505b61439c6143948561425c565b83018261433c565b50505b505050565b5f82821c905092915050565b5f6143bf5f19846008026143a4565b1980831691505092915050565b5f6143d783836143b0565b9150826002028217905092915050565b8181036143f55750506144ca565b6143fe82614235565b67ffffffffffffffff811115614417576144166134bf565b5b6144218254613cef565b61442c82828561435e565b5f601f831160018114614459575f8415614447578287015490505b61445185826143cc565b8655506144c3565b601f1984166144678761424a565b96506144728661424a565b5f5b8281101561449957848901548255600182019150600185019450602081019050614474565b868310156144b657848901546144b2601f8916826143b0565b8355505b6001600288020188555050505b5050505050505b565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f819050919050565b5f61453982614526565b915061454483614526565b925082820261455281614526565b91507f800000000000000000000000000000000000000000000000000000000000000084145f8412161561458957614588613bd2565b5b828205841483151761459e5761459d613bd2565b5b5092915050565b6145ae82613740565b67ffffffffffffffff8111156145c7576145c66134bf565b5b6145d18254613cef565b6145dc82828561435e565b5f60209050601f83116001811461460d575f84156145fb578287015190505b61460585826143cc565b86555061466c565b601f19841661461b8661424a565b5f5b828110156146425784890151825560018201915060208501945060208101905061461d565b8683101561465f578489015161465b601f8916826143b0565b8355505b6001600288020188555050505b505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b6146aa816139e8565b82525050565b5f6020820190506146c35f8301846146a1565b92915050565b6146d281614067565b82525050565b5f6080820190506146eb5f8301876146a1565b6146f860208301866146c9565b61470560408301856146a1565b61471260608301846146a1565b9594505050505056fea2646970667358221220b057cb9935d09df545118aca96718a6cdd232cb129b70de8782cd2d5d84bdc6964736f6c63430008180033",
}

// OnchainV1ABI is the input ABI used to generate the binding from.
// Deprecated: Use OnchainV1MetaData.ABI instead.
var OnchainV1ABI = OnchainV1MetaData.ABI

// OnchainV1Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OnchainV1MetaData.Bin instead.
var OnchainV1Bin = OnchainV1MetaData.Bin

// DeployOnchainV1 deploys a new Ethereum contract, binding an instance of OnchainV1 to it.
func DeployOnchainV1(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *OnchainV1, error) {
	parsed, err := OnchainV1MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OnchainV1Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &OnchainV1{OnchainV1Caller: OnchainV1Caller{contract: contract}, OnchainV1Transactor: OnchainV1Transactor{contract: contract}, OnchainV1Filterer: OnchainV1Filterer{contract: contract}}, nil
}

// OnchainV1 is an auto generated Go binding around an Ethereum contract.
type OnchainV1 struct {
	OnchainV1Caller     // Read-only binding to the contract
	OnchainV1Transactor // Write-only binding to the contract
	OnchainV1Filterer   // Log filterer for contract events
}

// OnchainV1Caller is an auto generated read-only Go binding around an Ethereum contract.
type OnchainV1Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainV1Transactor is an auto generated write-only Go binding around an Ethereum contract.
type OnchainV1Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainV1Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OnchainV1Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OnchainV1Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OnchainV1Session struct {
	Contract     *OnchainV1        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OnchainV1CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OnchainV1CallerSession struct {
	Contract *OnchainV1Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// OnchainV1TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OnchainV1TransactorSession struct {
	Contract     *OnchainV1Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// OnchainV1Raw is an auto generated low-level Go binding around an Ethereum contract.
type OnchainV1Raw struct {
	Contract *OnchainV1 // Generic contract binding to access the raw methods on
}

// OnchainV1CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OnchainV1CallerRaw struct {
	Contract *OnchainV1Caller // Generic read-only contract binding to access the raw methods on
}

// OnchainV1TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OnchainV1TransactorRaw struct {
	Contract *OnchainV1Transactor // Generic write-only contract binding to access the raw methods on
}

// NewOnchainV1 creates a new instance of OnchainV1, bound to a specific deployed contract.
func NewOnchainV1(address common.Address, backend bind.ContractBackend) (*OnchainV1, error) {
	contract, err := bindOnchainV1(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &OnchainV1{OnchainV1Caller: OnchainV1Caller{contract: contract}, OnchainV1Transactor: OnchainV1Transactor{contract: contract}, OnchainV1Filterer: OnchainV1Filterer{contract: contract}}, nil
}

// NewOnchainV1Caller creates a new read-only instance of OnchainV1, bound to a specific deployed contract.
func NewOnchainV1Caller(address common.Address, caller bind.ContractCaller) (*OnchainV1Caller, error) {
	contract, err := bindOnchainV1(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainV1Caller{contract: contract}, nil
}

// NewOnchainV1Transactor creates a new write-only instance of OnchainV1, bound to a specific deployed contract.
func NewOnchainV1Transactor(address common.Address, transactor bind.ContractTransactor) (*OnchainV1Transactor, error) {
	contract, err := bindOnchainV1(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OnchainV1Transactor{contract: contract}, nil
}

// NewOnchainV1Filterer creates a new log filterer instance of OnchainV1, bound to a specific deployed contract.
func NewOnchainV1Filterer(address common.Address, filterer bind.ContractFilterer) (*OnchainV1Filterer, error) {
	contract, err := bindOnchainV1(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OnchainV1Filterer{contract: contract}, nil
}

// bindOnchainV1 binds a generic wrapper to an already deployed contract.
func bindOnchainV1(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OnchainV1MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OnchainV1 *OnchainV1Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OnchainV1.Contract.OnchainV1Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OnchainV1 *OnchainV1Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OnchainV1.Contract.OnchainV1Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OnchainV1 *OnchainV1Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OnchainV1.Contract.OnchainV1Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OnchainV1 *OnchainV1CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OnchainV1.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OnchainV1 *OnchainV1TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OnchainV1.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OnchainV1 *OnchainV1TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OnchainV1.Contract.contract.Transact(opts, method, params...)
}

// GetAskOrders is a free data retrieval call binding the contract method 0x8545dca2.
//
// Solidity: function GetAskOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_OnchainV1 *OnchainV1Caller) GetAskOrders(opts *bind.CallOpts) ([]OnchainV1Batch, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "GetAskOrders")

	if err != nil {
		return *new([]OnchainV1Batch), err
	}

	out0 := *abi.ConvertType(out[0], new([]OnchainV1Batch)).(*[]OnchainV1Batch)

	return out0, err

}

// GetAskOrders is a free data retrieval call binding the contract method 0x8545dca2.
//
// Solidity: function GetAskOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_OnchainV1 *OnchainV1Session) GetAskOrders() ([]OnchainV1Batch, error) {
	return _OnchainV1.Contract.GetAskOrders(&_OnchainV1.CallOpts)
}

// GetAskOrders is a free data retrieval call binding the contract method 0x8545dca2.
//
// Solidity: function GetAskOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_OnchainV1 *OnchainV1CallerSession) GetAskOrders() ([]OnchainV1Batch, error) {
	return _OnchainV1.Contract.GetAskOrders(&_OnchainV1.CallOpts)
}

// GetBidOrders is a free data retrieval call binding the contract method 0x55a33968.
//
// Solidity: function GetBidOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_OnchainV1 *OnchainV1Caller) GetBidOrders(opts *bind.CallOpts) ([]OnchainV1Batch, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "GetBidOrders")

	if err != nil {
		return *new([]OnchainV1Batch), err
	}

	out0 := *abi.ConvertType(out[0], new([]OnchainV1Batch)).(*[]OnchainV1Batch)

	return out0, err

}

// GetBidOrders is a free data retrieval call binding the contract method 0x55a33968.
//
// Solidity: function GetBidOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_OnchainV1 *OnchainV1Session) GetBidOrders() ([]OnchainV1Batch, error) {
	return _OnchainV1.Contract.GetBidOrders(&_OnchainV1.CallOpts)
}

// GetBidOrders is a free data retrieval call binding the contract method 0x55a33968.
//
// Solidity: function GetBidOrders() view returns((bytes16,uint256,uint256,bool,address,bytes,uint256)[])
func (_OnchainV1 *OnchainV1CallerSession) GetBidOrders() ([]OnchainV1Batch, error) {
	return _OnchainV1.Contract.GetBidOrders(&_OnchainV1.CallOpts)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_OnchainV1 *OnchainV1Caller) AddressToString(opts *bind.CallOpts, _addr common.Address) (string, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "addressToString", _addr)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_OnchainV1 *OnchainV1Session) AddressToString(_addr common.Address) (string, error) {
	return _OnchainV1.Contract.AddressToString(&_OnchainV1.CallOpts, _addr)
}

// AddressToString is a free data retrieval call binding the contract method 0x5e57966d.
//
// Solidity: function addressToString(address _addr) pure returns(string)
func (_OnchainV1 *OnchainV1CallerSession) AddressToString(_addr common.Address) (string, error) {
	return _OnchainV1.Contract.AddressToString(&_OnchainV1.CallOpts, _addr)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_OnchainV1 *OnchainV1Caller) GetRegisterFee(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "getRegisterFee")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_OnchainV1 *OnchainV1Session) GetRegisterFee() (*big.Int, error) {
	return _OnchainV1.Contract.GetRegisterFee(&_OnchainV1.CallOpts)
}

// GetRegisterFee is a free data retrieval call binding the contract method 0x32a58e79.
//
// Solidity: function getRegisterFee() view returns(uint256)
func (_OnchainV1 *OnchainV1CallerSession) GetRegisterFee() (*big.Int, error) {
	return _OnchainV1.Contract.GetRegisterFee(&_OnchainV1.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_OnchainV1 *OnchainV1Caller) GetWaitingTime(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "getWaitingTime")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_OnchainV1 *OnchainV1Session) GetWaitingTime() (*big.Int, error) {
	return _OnchainV1.Contract.GetWaitingTime(&_OnchainV1.CallOpts)
}

// GetWaitingTime is a free data retrieval call binding the contract method 0x4dcbd09b.
//
// Solidity: function getWaitingTime() view returns(uint256)
func (_OnchainV1 *OnchainV1CallerSession) GetWaitingTime() (*big.Int, error) {
	return _OnchainV1.Contract.GetWaitingTime(&_OnchainV1.CallOpts)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_OnchainV1 *OnchainV1Caller) IsMatcher(opts *bind.CallOpts, _m common.Address) (bool, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "isMatcher", _m)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_OnchainV1 *OnchainV1Session) IsMatcher(_m common.Address) (bool, error) {
	return _OnchainV1.Contract.IsMatcher(&_OnchainV1.CallOpts, _m)
}

// IsMatcher is a free data retrieval call binding the contract method 0x36ee6749.
//
// Solidity: function isMatcher(address _m) view returns(bool)
func (_OnchainV1 *OnchainV1CallerSession) IsMatcher(_m common.Address) (bool, error) {
	return _OnchainV1.Contract.IsMatcher(&_OnchainV1.CallOpts, _m)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_OnchainV1 *OnchainV1Caller) IsPending(opts *bind.CallOpts, batchID [16]byte) (bool, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "isPending", batchID)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_OnchainV1 *OnchainV1Session) IsPending(batchID [16]byte) (bool, error) {
	return _OnchainV1.Contract.IsPending(&_OnchainV1.CallOpts, batchID)
}

// IsPending is a free data retrieval call binding the contract method 0x19f5e9fe.
//
// Solidity: function isPending(bytes16 batchID) view returns(bool)
func (_OnchainV1 *OnchainV1CallerSession) IsPending(batchID [16]byte) (bool, error) {
	return _OnchainV1.Contract.IsPending(&_OnchainV1.CallOpts, batchID)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_OnchainV1 *OnchainV1Caller) UintToString(opts *bind.CallOpts, num *big.Int) (string, error) {
	var out []interface{}
	err := _OnchainV1.contract.Call(opts, &out, "uintToString", num)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_OnchainV1 *OnchainV1Session) UintToString(num *big.Int) (string, error) {
	return _OnchainV1.Contract.UintToString(&_OnchainV1.CallOpts, num)
}

// UintToString is a free data retrieval call binding the contract method 0xe9395679.
//
// Solidity: function uintToString(uint256 num) pure returns(string)
func (_OnchainV1 *OnchainV1CallerSession) UintToString(num *big.Int) (string, error) {
	return _OnchainV1.Contract.UintToString(&_OnchainV1.CallOpts, num)
}

// DeleteBatch is a paid mutator transaction binding the contract method 0xb29e6299.
//
// Solidity: function deleteBatch(bytes16 batchID) returns()
func (_OnchainV1 *OnchainV1Transactor) DeleteBatch(opts *bind.TransactOpts, batchID [16]byte) (*types.Transaction, error) {
	return _OnchainV1.contract.Transact(opts, "deleteBatch", batchID)
}

// DeleteBatch is a paid mutator transaction binding the contract method 0xb29e6299.
//
// Solidity: function deleteBatch(bytes16 batchID) returns()
func (_OnchainV1 *OnchainV1Session) DeleteBatch(batchID [16]byte) (*types.Transaction, error) {
	return _OnchainV1.Contract.DeleteBatch(&_OnchainV1.TransactOpts, batchID)
}

// DeleteBatch is a paid mutator transaction binding the contract method 0xb29e6299.
//
// Solidity: function deleteBatch(bytes16 batchID) returns()
func (_OnchainV1 *OnchainV1TransactorSession) DeleteBatch(batchID [16]byte) (*types.Transaction, error) {
	return _OnchainV1.Contract.DeleteBatch(&_OnchainV1.TransactOpts, batchID)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_OnchainV1 *OnchainV1Transactor) Register(opts *bind.TransactOpts, _m common.Address) (*types.Transaction, error) {
	return _OnchainV1.contract.Transact(opts, "register", _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_OnchainV1 *OnchainV1Session) Register(_m common.Address) (*types.Transaction, error) {
	return _OnchainV1.Contract.Register(&_OnchainV1.TransactOpts, _m)
}

// Register is a paid mutator transaction binding the contract method 0x4420e486.
//
// Solidity: function register(address _m) payable returns()
func (_OnchainV1 *OnchainV1TransactorSession) Register(_m common.Address) (*types.Transaction, error) {
	return _OnchainV1.Contract.Register(&_OnchainV1.TransactOpts, _m)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_OnchainV1 *OnchainV1Transactor) ReportMissingDeadline(opts *bind.TransactOpts, batchID [16]byte) (*types.Transaction, error) {
	return _OnchainV1.contract.Transact(opts, "reportMissingDeadline", batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_OnchainV1 *OnchainV1Session) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _OnchainV1.Contract.ReportMissingDeadline(&_OnchainV1.TransactOpts, batchID)
}

// ReportMissingDeadline is a paid mutator transaction binding the contract method 0x78b32cf5.
//
// Solidity: function reportMissingDeadline(bytes16 batchID) returns()
func (_OnchainV1 *OnchainV1TransactorSession) ReportMissingDeadline(batchID [16]byte) (*types.Transaction, error) {
	return _OnchainV1.Contract.ReportMissingDeadline(&_OnchainV1.TransactOpts, batchID)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_OnchainV1 *OnchainV1Transactor) SendBatch(opts *bind.TransactOpts, batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _OnchainV1.contract.Transact(opts, "sendBatch", batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_OnchainV1 *OnchainV1Session) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _OnchainV1.Contract.SendBatch(&_OnchainV1.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SendBatch is a paid mutator transaction binding the contract method 0x3005d34c.
//
// Solidity: function sendBatch(bytes16 batchID, uint256 price, uint256 amount, bool side, address owner, bytes sign) returns()
func (_OnchainV1 *OnchainV1TransactorSession) SendBatch(batchID [16]byte, price *big.Int, amount *big.Int, side bool, owner common.Address, sign []byte) (*types.Transaction, error) {
	return _OnchainV1.Contract.SendBatch(&_OnchainV1.TransactOpts, batchID, price, amount, side, owner, sign)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x85d8a4e6.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32)[] _ords) returns()
func (_OnchainV1 *OnchainV1Transactor) SubmitOrderDetails(opts *bind.TransactOpts, batchID [16]byte, _ords []OnchainV1Order) (*types.Transaction, error) {
	return _OnchainV1.contract.Transact(opts, "submitOrderDetails", batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x85d8a4e6.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32)[] _ords) returns()
func (_OnchainV1 *OnchainV1Session) SubmitOrderDetails(batchID [16]byte, _ords []OnchainV1Order) (*types.Transaction, error) {
	return _OnchainV1.Contract.SubmitOrderDetails(&_OnchainV1.TransactOpts, batchID, _ords)
}

// SubmitOrderDetails is a paid mutator transaction binding the contract method 0x85d8a4e6.
//
// Solidity: function submitOrderDetails(bytes16 batchID, (uint256,uint256,bool,bytes16,bytes32,bytes32)[] _ords) returns()
func (_OnchainV1 *OnchainV1TransactorSession) SubmitOrderDetails(batchID [16]byte, _ords []OnchainV1Order) (*types.Transaction, error) {
	return _OnchainV1.Contract.SubmitOrderDetails(&_OnchainV1.TransactOpts, batchID, _ords)
}

// UpdateBatch is a paid mutator transaction binding the contract method 0x82736cd7.
//
// Solidity: function updateBatch(bytes16 batchID, uint256 amount) returns()
func (_OnchainV1 *OnchainV1Transactor) UpdateBatch(opts *bind.TransactOpts, batchID [16]byte, amount *big.Int) (*types.Transaction, error) {
	return _OnchainV1.contract.Transact(opts, "updateBatch", batchID, amount)
}

// UpdateBatch is a paid mutator transaction binding the contract method 0x82736cd7.
//
// Solidity: function updateBatch(bytes16 batchID, uint256 amount) returns()
func (_OnchainV1 *OnchainV1Session) UpdateBatch(batchID [16]byte, amount *big.Int) (*types.Transaction, error) {
	return _OnchainV1.Contract.UpdateBatch(&_OnchainV1.TransactOpts, batchID, amount)
}

// UpdateBatch is a paid mutator transaction binding the contract method 0x82736cd7.
//
// Solidity: function updateBatch(bytes16 batchID, uint256 amount) returns()
func (_OnchainV1 *OnchainV1TransactorSession) UpdateBatch(batchID [16]byte, amount *big.Int) (*types.Transaction, error) {
	return _OnchainV1.Contract.UpdateBatch(&_OnchainV1.TransactOpts, batchID, amount)
}

// OnchainV1AcceptBatchIterator is returned from FilterAcceptBatch and is used to iterate over the raw logs and unpacked data for AcceptBatch events raised by the OnchainV1 contract.
type OnchainV1AcceptBatchIterator struct {
	Event *OnchainV1AcceptBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1AcceptBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1AcceptBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1AcceptBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1AcceptBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1AcceptBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1AcceptBatch represents a AcceptBatch event raised by the OnchainV1 contract.
type OnchainV1AcceptBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAcceptBatch is a free log retrieval operation binding the contract event 0x48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d.
//
// Solidity: event AcceptBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterAcceptBatch(opts *bind.FilterOpts) (*OnchainV1AcceptBatchIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainV1AcceptBatchIterator{contract: _OnchainV1.contract, event: "AcceptBatch", logs: logs, sub: sub}, nil
}

// WatchAcceptBatch is a free log subscription operation binding the contract event 0x48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d.
//
// Solidity: event AcceptBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchAcceptBatch(opts *bind.WatchOpts, sink chan<- *OnchainV1AcceptBatch) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "AcceptBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1AcceptBatch)
				if err := _OnchainV1.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAcceptBatch is a log parse operation binding the contract event 0x48ecfbdd39de4d68f2a28458698ce634ea21a4083a608e845c14122c9d70bc0d.
//
// Solidity: event AcceptBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseAcceptBatch(log types.Log) (*OnchainV1AcceptBatch, error) {
	event := new(OnchainV1AcceptBatch)
	if err := _OnchainV1.contract.UnpackLog(event, "AcceptBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1FullfilMatchIterator is returned from FilterFullfilMatch and is used to iterate over the raw logs and unpacked data for FullfilMatch events raised by the OnchainV1 contract.
type OnchainV1FullfilMatchIterator struct {
	Event *OnchainV1FullfilMatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1FullfilMatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1FullfilMatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1FullfilMatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1FullfilMatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1FullfilMatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1FullfilMatch represents a FullfilMatch event raised by the OnchainV1 contract.
type OnchainV1FullfilMatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFullfilMatch is a free log retrieval operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterFullfilMatch(opts *bind.FilterOpts) (*OnchainV1FullfilMatchIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return &OnchainV1FullfilMatchIterator{contract: _OnchainV1.contract, event: "FullfilMatch", logs: logs, sub: sub}, nil
}

// WatchFullfilMatch is a free log subscription operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchFullfilMatch(opts *bind.WatchOpts, sink chan<- *OnchainV1FullfilMatch) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "FullfilMatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1FullfilMatch)
				if err := _OnchainV1.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFullfilMatch is a log parse operation binding the contract event 0x57c1c352bdac3386003c09fd995913d2076b2fcd7da4e5b8c98e19c1b08ae965.
//
// Solidity: event FullfilMatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseFullfilMatch(log types.Log) (*OnchainV1FullfilMatch, error) {
	event := new(OnchainV1FullfilMatch)
	if err := _OnchainV1.contract.UnpackLog(event, "FullfilMatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1InvalidBatchIterator is returned from FilterInvalidBatch and is used to iterate over the raw logs and unpacked data for InvalidBatch events raised by the OnchainV1 contract.
type OnchainV1InvalidBatchIterator struct {
	Event *OnchainV1InvalidBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1InvalidBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1InvalidBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1InvalidBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1InvalidBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1InvalidBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1InvalidBatch represents a InvalidBatch event raised by the OnchainV1 contract.
type OnchainV1InvalidBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidBatch is a free log retrieval operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterInvalidBatch(opts *bind.FilterOpts) (*OnchainV1InvalidBatchIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainV1InvalidBatchIterator{contract: _OnchainV1.contract, event: "InvalidBatch", logs: logs, sub: sub}, nil
}

// WatchInvalidBatch is a free log subscription operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchInvalidBatch(opts *bind.WatchOpts, sink chan<- *OnchainV1InvalidBatch) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "InvalidBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1InvalidBatch)
				if err := _OnchainV1.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidBatch is a log parse operation binding the contract event 0xe869c471359d4723739042b0d5604804b6d0b9a42b9d7542594ac99ef4fad748.
//
// Solidity: event InvalidBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseInvalidBatch(log types.Log) (*OnchainV1InvalidBatch, error) {
	event := new(OnchainV1InvalidBatch)
	if err := _OnchainV1.contract.UnpackLog(event, "InvalidBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1InvalidOrderIterator is returned from FilterInvalidOrder and is used to iterate over the raw logs and unpacked data for InvalidOrder events raised by the OnchainV1 contract.
type OnchainV1InvalidOrderIterator struct {
	Event *OnchainV1InvalidOrder // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1InvalidOrderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1InvalidOrder)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1InvalidOrder)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1InvalidOrderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1InvalidOrderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1InvalidOrder represents a InvalidOrder event raised by the OnchainV1 contract.
type OnchainV1InvalidOrder struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterInvalidOrder is a free log retrieval operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterInvalidOrder(opts *bind.FilterOpts) (*OnchainV1InvalidOrderIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return &OnchainV1InvalidOrderIterator{contract: _OnchainV1.contract, event: "InvalidOrder", logs: logs, sub: sub}, nil
}

// WatchInvalidOrder is a free log subscription operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchInvalidOrder(opts *bind.WatchOpts, sink chan<- *OnchainV1InvalidOrder) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "InvalidOrder")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1InvalidOrder)
				if err := _OnchainV1.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidOrder is a log parse operation binding the contract event 0xbadcacd8461f108d807dc434f432301d58e336cb63f5ce877e5e6a9298785447.
//
// Solidity: event InvalidOrder(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseInvalidOrder(log types.Log) (*OnchainV1InvalidOrder, error) {
	event := new(OnchainV1InvalidOrder)
	if err := _OnchainV1.contract.UnpackLog(event, "InvalidOrder", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1LogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the OnchainV1 contract.
type OnchainV1LogAddressIterator struct {
	Event *OnchainV1LogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1LogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1LogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1LogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1LogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1LogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1LogAddress represents a LogAddress event raised by the OnchainV1 contract.
type OnchainV1LogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterLogAddress(opts *bind.FilterOpts) (*OnchainV1LogAddressIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return &OnchainV1LogAddressIterator{contract: _OnchainV1.contract, event: "LogAddress", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *OnchainV1LogAddress) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "LogAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1LogAddress)
				if err := _OnchainV1.contract.UnpackLog(event, "LogAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0xb123f68b8ba02b447d91a6629e121111b7dd6061ff418a60139c8bf00522a284.
//
// Solidity: event LogAddress(address arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseLogAddress(log types.Log) (*OnchainV1LogAddress, error) {
	event := new(OnchainV1LogAddress)
	if err := _OnchainV1.contract.UnpackLog(event, "LogAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1LogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the OnchainV1 contract.
type OnchainV1LogBytesIterator struct {
	Event *OnchainV1LogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1LogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1LogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1LogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1LogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1LogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1LogBytes represents a LogBytes event raised by the OnchainV1 contract.
type OnchainV1LogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterLogBytes(opts *bind.FilterOpts) (*OnchainV1LogBytesIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return &OnchainV1LogBytesIterator{contract: _OnchainV1.contract, event: "LogBytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *OnchainV1LogBytes) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "LogBytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1LogBytes)
				if err := _OnchainV1.contract.UnpackLog(event, "LogBytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x532fd6ea96cfb78bb46e09279a26828b8b493de1a2b8b1ee1face527978a15a5.
//
// Solidity: event LogBytes(bytes arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseLogBytes(log types.Log) (*OnchainV1LogBytes, error) {
	event := new(OnchainV1LogBytes)
	if err := _OnchainV1.contract.UnpackLog(event, "LogBytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1LogBytes16Iterator is returned from FilterLogBytes16 and is used to iterate over the raw logs and unpacked data for LogBytes16 events raised by the OnchainV1 contract.
type OnchainV1LogBytes16Iterator struct {
	Event *OnchainV1LogBytes16 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1LogBytes16Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1LogBytes16)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1LogBytes16)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1LogBytes16Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1LogBytes16Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1LogBytes16 represents a LogBytes16 event raised by the OnchainV1 contract.
type OnchainV1LogBytes16 struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes16 is a free log retrieval operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterLogBytes16(opts *bind.FilterOpts) (*OnchainV1LogBytes16Iterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return &OnchainV1LogBytes16Iterator{contract: _OnchainV1.contract, event: "LogBytes16", logs: logs, sub: sub}, nil
}

// WatchLogBytes16 is a free log subscription operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchLogBytes16(opts *bind.WatchOpts, sink chan<- *OnchainV1LogBytes16) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "LogBytes16")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1LogBytes16)
				if err := _OnchainV1.contract.UnpackLog(event, "LogBytes16", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes16 is a log parse operation binding the contract event 0x9f7a2df33c1c92d195340c1708bc1c78ec4aed6cac45f305a0c9c9dcb5871207.
//
// Solidity: event LogBytes16(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseLogBytes16(log types.Log) (*OnchainV1LogBytes16, error) {
	event := new(OnchainV1LogBytes16)
	if err := _OnchainV1.contract.UnpackLog(event, "LogBytes16", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1LogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the OnchainV1 contract.
type OnchainV1LogBytes32Iterator struct {
	Event *OnchainV1LogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1LogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1LogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1LogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1LogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1LogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1LogBytes32 represents a LogBytes32 event raised by the OnchainV1 contract.
type OnchainV1LogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterLogBytes32(opts *bind.FilterOpts) (*OnchainV1LogBytes32Iterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return &OnchainV1LogBytes32Iterator{contract: _OnchainV1.contract, event: "LogBytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *OnchainV1LogBytes32) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "LogBytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1LogBytes32)
				if err := _OnchainV1.contract.UnpackLog(event, "LogBytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0x009fd52f05c0ded31d6fb0ee580b923f85e99cf1a5a1da342f25e73c45829c83.
//
// Solidity: event LogBytes32(bytes32 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseLogBytes32(log types.Log) (*OnchainV1LogBytes32, error) {
	event := new(OnchainV1LogBytes32)
	if err := _OnchainV1.contract.UnpackLog(event, "LogBytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1LogRecoverErrorIterator is returned from FilterLogRecoverError and is used to iterate over the raw logs and unpacked data for LogRecoverError events raised by the OnchainV1 contract.
type OnchainV1LogRecoverErrorIterator struct {
	Event *OnchainV1LogRecoverError // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1LogRecoverErrorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1LogRecoverError)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1LogRecoverError)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1LogRecoverErrorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1LogRecoverErrorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1LogRecoverError represents a LogRecoverError event raised by the OnchainV1 contract.
type OnchainV1LogRecoverError struct {
	Arg0 uint8
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogRecoverError is a free log retrieval operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterLogRecoverError(opts *bind.FilterOpts) (*OnchainV1LogRecoverErrorIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return &OnchainV1LogRecoverErrorIterator{contract: _OnchainV1.contract, event: "LogRecoverError", logs: logs, sub: sub}, nil
}

// WatchLogRecoverError is a free log subscription operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchLogRecoverError(opts *bind.WatchOpts, sink chan<- *OnchainV1LogRecoverError) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "LogRecoverError")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1LogRecoverError)
				if err := _OnchainV1.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogRecoverError is a log parse operation binding the contract event 0x9d91e3e6af4967817419b36cf53fb2a60335d23ebe396ea4f0da7ceb02a4f831.
//
// Solidity: event LogRecoverError(uint8 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseLogRecoverError(log types.Log) (*OnchainV1LogRecoverError, error) {
	event := new(OnchainV1LogRecoverError)
	if err := _OnchainV1.contract.UnpackLog(event, "LogRecoverError", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1LogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the OnchainV1 contract.
type OnchainV1LogStringIterator struct {
	Event *OnchainV1LogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1LogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1LogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1LogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1LogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1LogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1LogString represents a LogString event raised by the OnchainV1 contract.
type OnchainV1LogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterLogString(opts *bind.FilterOpts) (*OnchainV1LogStringIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return &OnchainV1LogStringIterator{contract: _OnchainV1.contract, event: "LogString", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *OnchainV1LogString) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "LogString")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1LogString)
				if err := _OnchainV1.contract.UnpackLog(event, "LogString", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0xa95e6e2a182411e7a6f9ed114a85c3761d87f9b8f453d842c71235aa64fff99f.
//
// Solidity: event LogString(string arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseLogString(log types.Log) (*OnchainV1LogString, error) {
	event := new(OnchainV1LogString)
	if err := _OnchainV1.contract.UnpackLog(event, "LogString", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1PartialMatchIterator is returned from FilterPartialMatch and is used to iterate over the raw logs and unpacked data for PartialMatch events raised by the OnchainV1 contract.
type OnchainV1PartialMatchIterator struct {
	Event *OnchainV1PartialMatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1PartialMatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1PartialMatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1PartialMatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1PartialMatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1PartialMatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1PartialMatch represents a PartialMatch event raised by the OnchainV1 contract.
type OnchainV1PartialMatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPartialMatch is a free log retrieval operation binding the contract event 0xcb56a4fd10f2bad2015ad7e01fb83de3e6d71a6f46eef88ebe216fd70f25efd4.
//
// Solidity: event PartialMatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterPartialMatch(opts *bind.FilterOpts) (*OnchainV1PartialMatchIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "PartialMatch")
	if err != nil {
		return nil, err
	}
	return &OnchainV1PartialMatchIterator{contract: _OnchainV1.contract, event: "PartialMatch", logs: logs, sub: sub}, nil
}

// WatchPartialMatch is a free log subscription operation binding the contract event 0xcb56a4fd10f2bad2015ad7e01fb83de3e6d71a6f46eef88ebe216fd70f25efd4.
//
// Solidity: event PartialMatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchPartialMatch(opts *bind.WatchOpts, sink chan<- *OnchainV1PartialMatch) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "PartialMatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1PartialMatch)
				if err := _OnchainV1.contract.UnpackLog(event, "PartialMatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePartialMatch is a log parse operation binding the contract event 0xcb56a4fd10f2bad2015ad7e01fb83de3e6d71a6f46eef88ebe216fd70f25efd4.
//
// Solidity: event PartialMatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParsePartialMatch(log types.Log) (*OnchainV1PartialMatch, error) {
	event := new(OnchainV1PartialMatch)
	if err := _OnchainV1.contract.UnpackLog(event, "PartialMatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1PunishMatcherIterator is returned from FilterPunishMatcher and is used to iterate over the raw logs and unpacked data for PunishMatcher events raised by the OnchainV1 contract.
type OnchainV1PunishMatcherIterator struct {
	Event *OnchainV1PunishMatcher // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1PunishMatcherIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1PunishMatcher)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1PunishMatcher)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1PunishMatcherIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1PunishMatcherIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1PunishMatcher represents a PunishMatcher event raised by the OnchainV1 contract.
type OnchainV1PunishMatcher struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterPunishMatcher is a free log retrieval operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterPunishMatcher(opts *bind.FilterOpts) (*OnchainV1PunishMatcherIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return &OnchainV1PunishMatcherIterator{contract: _OnchainV1.contract, event: "PunishMatcher", logs: logs, sub: sub}, nil
}

// WatchPunishMatcher is a free log subscription operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchPunishMatcher(opts *bind.WatchOpts, sink chan<- *OnchainV1PunishMatcher) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "PunishMatcher")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1PunishMatcher)
				if err := _OnchainV1.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePunishMatcher is a log parse operation binding the contract event 0x5d03dcef971a6d5b97413cad12abae79f43e9422a6c38e8bc70592b18937ba23.
//
// Solidity: event PunishMatcher(address arg0)
func (_OnchainV1 *OnchainV1Filterer) ParsePunishMatcher(log types.Log) (*OnchainV1PunishMatcher, error) {
	event := new(OnchainV1PunishMatcher)
	if err := _OnchainV1.contract.UnpackLog(event, "PunishMatcher", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1ReceivedBatchDetailsIterator is returned from FilterReceivedBatchDetails and is used to iterate over the raw logs and unpacked data for ReceivedBatchDetails events raised by the OnchainV1 contract.
type OnchainV1ReceivedBatchDetailsIterator struct {
	Event *OnchainV1ReceivedBatchDetails // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1ReceivedBatchDetailsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1ReceivedBatchDetails)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1ReceivedBatchDetails)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1ReceivedBatchDetailsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1ReceivedBatchDetailsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1ReceivedBatchDetails represents a ReceivedBatchDetails event raised by the OnchainV1 contract.
type OnchainV1ReceivedBatchDetails struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterReceivedBatchDetails is a free log retrieval operation binding the contract event 0x9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterReceivedBatchDetails(opts *bind.FilterOpts) (*OnchainV1ReceivedBatchDetailsIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return &OnchainV1ReceivedBatchDetailsIterator{contract: _OnchainV1.contract, event: "ReceivedBatchDetails", logs: logs, sub: sub}, nil
}

// WatchReceivedBatchDetails is a free log subscription operation binding the contract event 0x9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchReceivedBatchDetails(opts *bind.WatchOpts, sink chan<- *OnchainV1ReceivedBatchDetails) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "ReceivedBatchDetails")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1ReceivedBatchDetails)
				if err := _OnchainV1.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseReceivedBatchDetails is a log parse operation binding the contract event 0x9e82d75e1d25a2db33e754b50ce9378e4c2e505c68c05de244b398543c0e422e.
//
// Solidity: event ReceivedBatchDetails(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseReceivedBatchDetails(log types.Log) (*OnchainV1ReceivedBatchDetails, error) {
	event := new(OnchainV1ReceivedBatchDetails)
	if err := _OnchainV1.contract.UnpackLog(event, "ReceivedBatchDetails", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1RemoveBatchOutOfDateIterator is returned from FilterRemoveBatchOutOfDate and is used to iterate over the raw logs and unpacked data for RemoveBatchOutOfDate events raised by the OnchainV1 contract.
type OnchainV1RemoveBatchOutOfDateIterator struct {
	Event *OnchainV1RemoveBatchOutOfDate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1RemoveBatchOutOfDateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1RemoveBatchOutOfDate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1RemoveBatchOutOfDate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1RemoveBatchOutOfDateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1RemoveBatchOutOfDateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1RemoveBatchOutOfDate represents a RemoveBatchOutOfDate event raised by the OnchainV1 contract.
type OnchainV1RemoveBatchOutOfDate struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRemoveBatchOutOfDate is a free log retrieval operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterRemoveBatchOutOfDate(opts *bind.FilterOpts) (*OnchainV1RemoveBatchOutOfDateIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return &OnchainV1RemoveBatchOutOfDateIterator{contract: _OnchainV1.contract, event: "RemoveBatchOutOfDate", logs: logs, sub: sub}, nil
}

// WatchRemoveBatchOutOfDate is a free log subscription operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchRemoveBatchOutOfDate(opts *bind.WatchOpts, sink chan<- *OnchainV1RemoveBatchOutOfDate) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "RemoveBatchOutOfDate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1RemoveBatchOutOfDate)
				if err := _OnchainV1.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRemoveBatchOutOfDate is a log parse operation binding the contract event 0xef2d1181ef6c5750f7ef1076cc112a454f5bf01f65b8e40daeb7390d2b660220.
//
// Solidity: event RemoveBatchOutOfDate(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseRemoveBatchOutOfDate(log types.Log) (*OnchainV1RemoveBatchOutOfDate, error) {
	event := new(OnchainV1RemoveBatchOutOfDate)
	if err := _OnchainV1.contract.UnpackLog(event, "RemoveBatchOutOfDate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OnchainV1RevertBatchIterator is returned from FilterRevertBatch and is used to iterate over the raw logs and unpacked data for RevertBatch events raised by the OnchainV1 contract.
type OnchainV1RevertBatchIterator struct {
	Event *OnchainV1RevertBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OnchainV1RevertBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OnchainV1RevertBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OnchainV1RevertBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OnchainV1RevertBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OnchainV1RevertBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OnchainV1RevertBatch represents a RevertBatch event raised by the OnchainV1 contract.
type OnchainV1RevertBatch struct {
	Arg0 [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRevertBatch is a free log retrieval operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) FilterRevertBatch(opts *bind.FilterOpts) (*OnchainV1RevertBatchIterator, error) {

	logs, sub, err := _OnchainV1.contract.FilterLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return &OnchainV1RevertBatchIterator{contract: _OnchainV1.contract, event: "RevertBatch", logs: logs, sub: sub}, nil
}

// WatchRevertBatch is a free log subscription operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) WatchRevertBatch(opts *bind.WatchOpts, sink chan<- *OnchainV1RevertBatch) (event.Subscription, error) {

	logs, sub, err := _OnchainV1.contract.WatchLogs(opts, "RevertBatch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OnchainV1RevertBatch)
				if err := _OnchainV1.contract.UnpackLog(event, "RevertBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRevertBatch is a log parse operation binding the contract event 0xf335387fffae8d4c523007d8c373bffc677e94ca97652a6dabecea00f48e4dd6.
//
// Solidity: event RevertBatch(bytes16 arg0)
func (_OnchainV1 *OnchainV1Filterer) ParseRevertBatch(log types.Log) (*OnchainV1RevertBatch, error) {
	event := new(OnchainV1RevertBatch)
	if err := _OnchainV1.contract.UnpackLog(event, "RevertBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
